name: Convert Draw.io Files

on:
  push:
    paths:
      - '**/*.drawio'
      - 'drawio_files/**'
  workflow_dispatch: # Enable manual triggering

# Add concurrency control to prevent queued workflows and resolve XKEYBOARD issues
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}-${{ github.sha }}
  cancel-in-progress: false

# Add permissions needed for the workflow
permissions:
  contents: write

jobs:
  convert:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Check out the repository with history to detect changes
      - name: Check out the repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch all history to properly identify changed files
          
      # Step 1.1: Diagnostic information
      - name: Workflow diagnostic information
        run: |
          echo "============================================"
          echo "WORKFLOW DIAGNOSTIC INFORMATION"
          echo "============================================"
          echo "Repository: ${{ github.repository }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Actor: ${{ github.actor }}"
          echo "Workflow: ${{ github.workflow }}"
          echo "Event: ${{ github.event_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "============================================"
          echo "LISTING DRAWIO FILES:"
          find drawio_files -name "*.drawio" -type f 2>/dev/null | sort || echo "No .drawio files found"
          echo "============================================"
          echo "GIT STATUS:"
          git status
          echo "============================================"
          echo "RECENTLY MODIFIED FILES:"
          git diff --name-only HEAD~5 HEAD 2>/dev/null || echo "Cannot get recent changes"
          echo "============================================"

      - name: Assign IDs to New Drawio Files
        shell: bash # Explicitly set shell to bash
        run: |
          set -ex # Enable verbose debugging and exit on error. MUST BE THE FIRST LINE.
          echo "============================================"
          echo "ASSIGNING IDS TO NEW DRAWIO FILES"
          echo "============================================"
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"

          ID_COUNTER_FILE="drawio_files/.id_counter"
          NEW_IDS_WERE_ASSIGNED=false

          # Initialize counter file if it doesn't exist
          if [ ! -f "$ID_COUNTER_FILE" ]; then
            echo "Initializing ID counter file: $ID_COUNTER_FILE"
            # Ensure the directory exists before trying to create the file
            mkdir -p "$(dirname "$ID_COUNTER_FILE")"
            echo "0" > "$ID_COUNTER_FILE"
            git add "$ID_COUNTER_FILE" # Stage it if newly created
          fi

          CURRENT_ID=$(cat "$ID_COUNTER_FILE")
          echo "Current last assigned ID from counter is: $CURRENT_ID"

          # Determine files to process
          FILES_TO_PROCESS=()
          echo "Event name: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "SHA: ${{ github.sha }}"
          echo "Before SHA: ${{ github.event.before }}"
          echo "After SHA: ${{ github.event.after }}" # Same as github.sha for push

          # Refactored conditional logic
          if [[ "${{ github.event_name }}" == "push" ]]; then
            echo "Event is PUSH."
            if [[ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]]; then
              # Push to an existing branch
              echo "Push event to existing branch. Scanning for .drawio files added between ${{ github.event.before }} and ${{ github.sha }}."
              echo "Running command: git diff --name-only --diff-filter=A ${{ github.event.before }} ${{ github.sha }} -- 'drawio_files/**/*.drawio'"
              
              TEMP_DIFF_OUTPUT_FILE=$(mktemp)
              if [ -z "$TEMP_DIFF_OUTPUT_FILE" ] || [ ! -f "$TEMP_DIFF_OUTPUT_FILE" ]; then
                echo "::error::Failed to create temporary file with mktemp. Path was: '$TEMP_DIFF_OUTPUT_FILE'"
                exit 1
              fi
              echo "Temporary file created: ${TEMP_DIFF_OUTPUT_FILE}"
              
              if ! git diff --name-only --diff-filter=A ${{ github.event.before }} ${{ github.sha }} -- 'drawio_files/**/*.drawio' > "${TEMP_DIFF_OUTPUT_FILE}"; then
                echo "Warning: git diff command exited with non-zero status. Output (if any) was:"
                cat "${TEMP_DIFF_OUTPUT_FILE}"
              fi
              
              echo "--- Start of git diff output (from ${TEMP_DIFF_OUTPUT_FILE}) ---"
              cat "${TEMP_DIFF_OUTPUT_FILE}"
              echo "--- End of git diff output (from ${TEMP_DIFF_OUTPUT_FILE}) ---"
              echo "Details of temporary file ${TEMP_DIFF_OUTPUT_FILE}:"
              ls -l "${TEMP_DIFF_OUTPUT_FILE}"

              if [ ! -s "${TEMP_DIFF_OUTPUT_FILE}" ]; then
                  echo "Temporary file ${TEMP_DIFF_OUTPUT_FILE} is empty or does not exist. No files to process from diff."
              else
                  echo "Temporary file ${TEMP_DIFF_OUTPUT_FILE} is NOT empty. Processing contents."
                  LOOP_ITERATIONS=0
                  while IFS= read -r file; do 
                      LOOP_ITERATIONS=$((LOOP_ITERATIONS + 1))
                      echo "Loop iteration: $LOOP_ITERATIONS. Raw line read: <<<${file}>>>"
                      if [[ -z "$file" ]]; then 
                          echo "Line read from temp file was empty. Skipping."
                          continue
                      fi
                      echo "Processing file from diff: '$file'"
                      if [[ "$file" == drawio_files/* && "$file" == *.drawio ]]; then
                          echo "File '$file' matches criteria, adding to FILES_TO_PROCESS."
                          FILES_TO_PROCESS+=("$file")
                      else
                          echo "File '$file' from git diff output does NOT match 'drawio_files/*' and '*.drawio'."
                      fi
                  done < "${TEMP_DIFF_OUTPUT_FILE}"
                  echo "Finished loop over diff output. Total iterations: $LOOP_ITERATIONS."
              fi
              rm -f "${TEMP_DIFF_OUTPUT_FILE}"
            else
              # Push to a new branch or initial commit (for a PUSH event)
              echo "Push event for a new branch or initial commit. Scanning all .drawio files in commit ${{ github.sha }} using git diff-tree."
              echo "Scanning with git diff-tree for commit ${{ github.sha }}..."
              TREE_LOOP_ITERATIONS=0
              while IFS= read -r file || [ -n "$file" ]; do
                TREE_LOOP_ITERATIONS=$((TREE_LOOP_ITERATIONS + 1))
                echo "Tree Loop (new branch push): $TREE_LOOP_ITERATIONS. Raw line read: <<<${file}>>>"
                if [[ -z "$file" ]]; then
                  echo "Skipping empty line from git diff-tree (new branch push)."
                  continue
                fi
                if [[ "$file" == drawio_files/* && "$file" == *.drawio ]]; then
                  echo "File '$file' (from tree, new branch push) matches criteria, adding to FILES_TO_PROCESS."
                  FILES_TO_PROCESS+=("$file")
                else
                  echo "File '$file' (from tree, new branch push) does NOT match criteria."
                fi
              done < <(git diff-tree --no-commit-id --name-only -r ${{ github.sha }} -- 'drawio_files/**/*.drawio')
              echo "Finished tree loop (new branch push). Total iterations: $TREE_LOOP_ITERATIONS."
            fi
          else
            # Not a push event (e.g., workflow_dispatch)
            echo "Event is NOT PUSH (${{ github.event_name }}). Scanning all .drawio files in commit ${{ github.sha }} using git diff-tree."
            if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
              echo "Workflow dispatch event. Scanning all .drawio files in commit ${{ github.sha }}."
            else
              echo "Unknown non-push event type (${{ github.event_name }}). Scanning all .drawio files in commit ${{ github.sha }} as a fallback."
            fi
            echo "Scanning with git diff-tree for commit ${{ github.sha }}..."
            TREE_LOOP_ITERATIONS=0
            while IFS= read -r file || [ -n "$file" ]; do
              TREE_LOOP_ITERATIONS=$((TREE_LOOP_ITERATIONS + 1))
              echo "Tree Loop (non-push): $TREE_LOOP_ITERATIONS. Raw line read: <<<${file}>>>"
              if [[ -z "$file" ]]; then
                echo "Skipping empty line from git diff-tree (non-push)."
                continue
              fi
              if [[ "$file" == drawio_files/* && "$file" == *.drawio ]]; then
                echo "File '$file' (from tree, non-push) matches criteria, adding to FILES_TO_PROCESS."
                FILES_TO_PROCESS+=("$file")
              else
                echo "File '$file' (from tree, non-push) does NOT match criteria."
              fi
            done < <(git diff-tree --no-commit-id --name-only -r ${{ github.sha }} -- 'drawio_files/**/*.drawio')
            echo "Finished tree loop (non-push). Total iterations: $TREE_LOOP_ITERATIONS."
          fi


          # Always do a fallback scan: assign IDs to any .drawio file missing an ID, every run
          echo "\n===== Fallback: Scanning all drawio_files/*.drawio for missing IDs ====="
          for file_path in drawio_files/*.drawio; do
            [ -f "$file_path" ] || continue
            original_basename=$(basename "$file_path" .drawio)
            file_dir=$(dirname "$file_path")
            # If file already has an ID, skip
            if [[ "$original_basename" =~ \ \([0-9]{3}\)$ ]]; then
              echo "(Fallback) File '$file_path' already has an ID pattern. Skipping."
              continue
            fi
            # Check if a file with the same base name and an ID already exists
            base_no_id="$original_basename"
            existing_with_id=$(find "$file_dir" -maxdepth 1 -type f -name "${base_no_id} (*)*.drawio" | head -n 1)
            if [ -n "$existing_with_id" ]; then
              echo "(Fallback) File with base '$base_no_id' already has an ID: $existing_with_id. Skipping assigning a new ID to '$file_path'."
              continue
            fi
            echo "(Fallback) File '$file_path' does NOT have an ID pattern and no existing file with an ID. Assigning new ID."
            CURRENT_ID=$((CURRENT_ID + 1))
            FORMATTED_ID=$(printf "%03d" "$CURRENT_ID")
            new_filename_base="${original_basename} (${FORMATTED_ID})"
            new_filepath="${file_dir}/${new_filename_base}.drawio"
            echo "(Fallback) Attempting to rename: '$file_path' to '$new_filepath'"

            # Get the commit hash, message, and author for the commit that added this file
            orig_commit_hash=$(git log --diff-filter=A --format="%H" -- "$file_path" | head -n 1)
            orig_commit_msg=$(git log --diff-filter=A --format="%s" -- "$file_path" | head -n 1)
            orig_commit_author=$(git log --diff-filter=A --format="%an <%ae>" -- "$file_path" | head -n 1)
            orig_commit_date=$(git log --diff-filter=A --format="%cI" -- "$file_path" | head -n 1)

            if [ -z "$orig_commit_msg" ]; then
              orig_commit_msg="Chore: Assign IDs to new diagrams and update counter [skip ci]"
            fi
            if [ -z "$orig_commit_author" ]; then
              orig_commit_author="github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
            fi
            if [ -z "$orig_commit_date" ]; then
              orig_commit_date="$(date -Iseconds)"
            fi

            if git mv "$file_path" "$new_filepath"; then
              echo "(Fallback) SUCCESS: git mv command executed for '$file_path'."
              # After git mv, sometimes the original file may still exist due to case-insensitive FS or git quirks. Remove it if present.
              if [ -f "$file_path" ]; then
                echo "(Fallback) WARNING: Original file '$file_path' still exists after git mv. Removing it."
                rm -f "$file_path"
                if [ ! -f "$file_path" ]; then
                  echo "(Fallback) VERIFIED: '$file_path' successfully removed after manual rm."
                else
                  echo "(Fallback) ERROR: Failed to remove '$file_path' after manual rm."
                fi
              fi
              if [ -f "$new_filepath" ] && [ ! -f "$file_path" ]; then
                echo "(Fallback) VERIFIED: '$new_filepath' exists and '$file_path' is removed."
                NEW_IDS_WERE_ASSIGNED=true
                # Stage the rename
                git add "$new_filepath"
                # Commit the rename with the original commit message and author
                GIT_COMMITTER_DATE="$orig_commit_date" git commit --author="$orig_commit_author" -m "$orig_commit_msg" --no-verify || \
                git commit -m "$orig_commit_msg" --no-verify
              else
                echo "(Fallback) ERROR: Post-mv verification FAILED for '$new_filepath'."
                echo "(Fallback) Details: '$new_filepath' exists? $(test -f "$new_filepath" && echo YES || echo NO). '$file_path' exists? $(test -f "$file_path" && echo YES || echo NO)."
              fi
            else
              MV_EXIT_CODE=$?
              echo "(Fallback) ERROR: git mv '$file_path' '$new_filepath' FAILED with exit code $MV_EXIT_CODE."
              if [ -e "$new_filepath" ]; then
                echo "(Fallback) DIAGNOSTIC: Target '$new_filepath' already exists on disk."
              fi
              if [ ! -e "$file_path" ]; then
                echo "(Fallback) DIAGNOSTIC: Source '$file_path' does not exist prior to mv command (unexpected)."
              fi
            fi
          done

          if [ "$NEW_IDS_WERE_ASSIGNED" = true ]; then
            echo "New IDs were assigned. Updating counter to $CURRENT_ID and committing changes."
            echo "$CURRENT_ID" > "$ID_COUNTER_FILE"
            git add "$ID_COUNTER_FILE"
            
            echo "Staging status after ID assignment:"
            git status # For logging
            
            # Check if there are changes to commit (counter or renamed files)
            if ! git diff --staged --quiet; then
              echo "Committing ID assignments and counter update..."
              # Only commit the counter file if there are changes (renames are already committed above)
              if git diff --cached --name-only | grep -q ".id_counter"; then
                git commit -m "Chore: Update diagram ID counter [skip ci]"
              fi
              echo "Pushing ID assignment changes to branch ${{ github.ref_name }}..."
              # Using GITHUB_TOKEN for push
              if git push "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" HEAD:${{ github.ref_name }}; then
                echo "Push successful."
              else
                echo "::error::Push failed!"
                # Optionally, exit 1 here if push failure should fail the step
              fi
              echo "Pulling latest changes to sync workspace after ID assignment push..."
              if git pull --rebase "https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" ${{ github.ref_name }}; then
                echo "Pull --rebase successful."
              else
                echo "::warning::Pull --rebase failed. Workspace might not be fully synced."
              fi
            else
              echo "No changes staged for commit. This is unexpected if NEW_IDS_WERE_ASSIGNED was true ('$NEW_IDS_WERE_ASSIGNED'). Check if files were actually moved and staged."
            fi
          else
            echo "No new IDs were assigned in this run."
          fi

          # Cleanup: Remove any non-ID'd .drawio files that remain (to prevent duplicates)
          echo "===== Cleanup: Removing any non-ID'd .drawio files remaining in drawio_files/ ====="
          for file_path in drawio_files/*.drawio; do
            [ -f "$file_path" ] || continue
            original_basename=$(basename "$file_path" .drawio)
            if [[ ! "$original_basename" =~ \ \([0-9]{3}\)$ ]]; then
              echo "Cleanup: Removing non-ID'd file '$file_path'"
              git rm -f "$file_path" || rm -f "$file_path"
            fi
          done
          echo "============================================"

      # Step 2: Install dependencies
      - name: Install dependencies
        run: |
          echo "============================================"
          echo "INSTALLING DRAW.IO AND DEPENDENCIES"
          echo "============================================"
          sudo apt-get update
          # Essential dependencies for drawio-desktop on Ubuntu Noble (24.04)
          # xvfb is for headless operation.
          # libasound2t64 and others are runtime dependencies for drawio.
          sudo apt-get install -y wget xvfb libasound2t64 libgbm1 libnspr4 libnss3 libxss1
          
          # Download and install drawio-desktop
          # Using v26.2.2 as it was mentioned previously and is a known version.
          DRAWIO_VERSION_TAG="v26.2.2"
          DRAWIO_VERSION_FILE="26.2.2"
          DRAWIO_DEB_URL="https://github.com/jgraph/drawio-desktop/releases/download/${DRAWIO_VERSION_TAG}/drawio-amd64-${DRAWIO_VERSION_FILE}.deb"

          echo "Downloading Draw.io Desktop from ${DRAWIO_DEB_URL}"
          wget -O drawio-desktop.deb "${DRAWIO_DEB_URL}"
          
          echo "Installing Draw.io Desktop..."
          # Using apt to install the local .deb file handles dependencies automatically.
          sudo apt-get install -y ./drawio-desktop.deb
          
          # Verify installations
          echo "Installed versions:"
          if command -v Xvfb &> /dev/null; then 
            echo "Xvfb found. Attempting to get version..."
            # Try Xvfb -V, redirect stderr to stdout as version info often goes there
            Xvfb -V 2>&1 || echo "Xvfb -V failed, checking package version:" $(dpkg -s xvfb 2>/dev/null | grep Version || echo "dpkg query failed")
          else 
            echo "Xvfb NOT found."
          fi
          
          if command -v drawio &> /dev/null; then 
            echo "drawio command found. Attempting to get version using xvfb-run..."
            # Run drawio --version within xvfb-run to provide a virtual display
            xvfb-run --auto-servernum --server-args="-screen 0 1024x768x24" drawio --version || echo "drawio --version failed even with xvfb-run"
          else 
            echo "drawio command NOT found. This could indicate an issue with the installation."
          fi
          echo "============================================"

      # Step 3: Convert Draw.io files to HTML and SVG
      - name: Convert Draw.io files to HTML and SVG
        run: |
          echo "============================================"
          echo "CONVERTING DRAW.IO FILES TO HTML AND SVG"
          echo "============================================"
          
          # Ensure output directories exist
          mkdir -p svg_files html_files
          
          # Create a simple converter script
          cat > /tmp/convert-drawio.sh << 'EOL'
          #!/bin/bash
          input_file=$1
          output_file=$2
          echo "Converting: $input_file to $output_file"
          
          # Try direct command first
          if drawio -x -f svg -o "$output_file" "$input_file"; then
            exit 0
          fi
          
          # Try with xvfb-run as fallback
          xvfb-run --auto-servernum --server-args="-screen 0 1280x1024x24" drawio -x -f svg -o "$output_file" "$input_file"
          EOL
          chmod +x /tmp/convert-drawio.sh
          
          # Track processed files
          > /tmp/processed_files.txt
          > /tmp/failed_files.txt


          # Only process .drawio files with an ID in the filename that were added or modified in the last commit

      echo "Detecting changed ID'd .drawio files in the last commit..."
      # Get list of added or modified .drawio files with an ID in the filename
      git diff --name-only --diff-filter=AM HEAD^ HEAD -- 'drawio_files/* ([0-9][0-9][0-9]).drawio' | sort > /tmp/changed_files.txt

      # Fallback for initial commit (no HEAD^)
      if [ ! -s /tmp/changed_files.txt ]; then
        git diff-tree --no-commit-id --name-only -r HEAD -- 'drawio_files/* ([0-9][0-9][0-9]).drawio' | sort > /tmp/changed_files.txt
      fi

      echo "Files to process (ID'd .drawio files changed in this commit):"
      cat /tmp/changed_files.txt

          # Process each changed file

          while IFS= read -r file || [ -n "$file" ]; do
            if [ -f "$file" ]; then
              echo "Processing: $file"

              # Create output directories
              mkdir -p svg_files html_files

              # Get base name
              base=$(basename "$file" .drawio)
              output_svg="svg_files/${base}.svg"
              output_html="html_files/${base}.html"

              # Convert to SVG (robust quoting)
              echo "Converting to SVG..."
              if /tmp/convert-drawio.sh "$file" "$output_svg"; then
                echo "✅ Successfully converted to SVG: $output_svg"
              else
                echo "❌ Failed to convert: $file"
                echo "$file" >> /tmp/failed_files.txt
                # Create a placeholder SVG for failed conversions
                echo '<svg xmlns="http://www.w3.org/2000/svg" width="640" height="480" viewBox="0 0 640 480">' > "$output_svg"
                echo '  <rect width="100%" height="100%" fill="#ffffcc"/>' >> "$output_svg"
                echo '  <text x="10" y="20" font-family="Arial" font-size="16">Error: Failed to convert diagram</text>' >> "$output_svg"
                echo '  <text x="10" y="45" font-family="Arial" font-size="12">Please check the file and try again</text>' >> "$output_svg"
                echo '</svg>' >> "$output_svg"
              fi

              # Only create HTML wrapper if SVG exists
              if [ -f "$output_svg" ]; then
                echo "Creating HTML wrapper..."
                echo '<!DOCTYPE html>' > "$output_html"
                echo '<html lang="en">' >> "$output_html"
                echo '<head>' >> "$output_html"
                echo '  <meta charset="UTF-8">' >> "$output_html"
                echo "  <title>$base</title>" >> "$output_html"
                echo '  <style>body { margin: 0; padding: 0; } svg { max-width: 100%; height: auto; display: block; }</style>' >> "$output_html"
                echo '</head>' >> "$output_html"
                echo '<body>' >> "$output_html"
                cat "$output_svg" >> "$output_html"
                echo '</body>' >> "$output_html"
                echo '</html>' >> "$output_html"

                # Get full commit history for the file (message|hash|author|email|date), up to 10 entries
                log_lines=$(git log --follow --find-renames=40% --format="%s|%h|%an|%ae|%cI" -- "$file" | head -n 10)
                commit_msg=""
                commit_hash=""
                commit_author=""
                commit_email=""
                commit_date=""
                # Find the first non-Chore commit in the history
                while IFS= read -r line; do
                  msg="${line%%|*}"
                  rest="${line#*|}"
                  hash="${rest%%|*}"
                  rest2="${rest#*|}"
                  author="${rest2%%|*}"
                  rest3="${rest2#*|}"
                  email="${rest3%%|*}"
                  date="${rest3#*|}"
                  if [[ "$msg" != "Chore: Assign IDs to new diagrams and update counter [skip ci]" ]]; then
                    commit_msg="$msg"
                    commit_hash="$hash"
                    commit_author="$author"
                    commit_email="$email"
                    commit_date="$date"
                    break
                  fi
                done <<< "$log_lines"
                # If all commits are Chore, fallback to the first one
                if [ -z "$commit_msg" ]; then
                  IFS=$'\n' read -r first_line _ <<< "$log_lines"
                  if [ -n "$first_line" ]; then
                    commit_msg="${first_line%%|*}"
                    rest="${first_line#*|}"
                    commit_hash="${rest%%|*}"
                    rest2="${rest#*|}"
                    commit_author="${rest2%%|*}"
                    rest3="${rest2#*|}"
                    commit_email="${rest3%%|*}"
                    commit_date="${rest3#*|}"
                  fi
                fi

                # Determine versioning for this file
                changelog_file="html_files/CHANGELOG.csv"
                last_version=""
                if [ -f "$changelog_file" ]; then
                  # Get the last version for this file from the changelog (search for the file path, get last match)
                  last_version=$(awk -F',' -v f="$file" 'tolower($4)==tolower(f){print $(NF-1)}' "$changelog_file" | tail -n 1)
                fi
                # If no version found, start at 1.0
                if [[ -z "$last_version" || ! "$last_version" =~ ^[0-9]+\.[0-9]+$ ]]; then
                  new_version="1.0"
                else
                  major=${last_version%%.*}
                  minor=${last_version##*.}
                  # Check commit message for major keywords
                  if echo "$commit_msg" | grep -Eiq '(major|redesign|breaking|release)'; then
                    major=$((major+1))
                    minor=0
                  else
                    minor=$((minor+1))
                  fi
                  new_version="$major.$minor"
                fi

                echo "$(date +"%d.%m.%Y"),$(date +"%H:%M:%S"),\"$base\",\"$file\",\"\",\"$commit_msg\",$new_version,\"$commit_hash\"" >> html_files/CHANGELOG.csv
                echo "$file" >> /tmp/processed_files.txt
              else
                echo "❌ SVG output missing for $file, skipping HTML wrapper."
              fi
            else
              echo "⚠️ File not found: $file"
            fi
          done < /tmp/changed_files.txt

          echo "Process completed."
          echo "Successful conversions: $(wc -l < /tmp/processed_files.txt)"
          echo "Failed conversions: $(wc -l < /tmp/failed_files.txt)"

      # Step 5: Commit and push changes
      - name: Commit and push changes
        id: commit_changes
        run: |
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          
          # Fetch latest changes before adding our changes
          echo "Fetching latest changes from remote repository..."
          git fetch origin
          
          # Add our changes
          git add svg_files html_files
          
          # Only commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "changes_made=false" >> $GITHUB_OUTPUT
          else
            git commit -m "Auto-converted draw.io files"
            
            # Pull the latest changes before pushing
            echo "Pulling latest changes from remote repository..."
            git pull --rebase origin ${GITHUB_REF#refs/heads/}
            
            # Use GitHub token for authentication and push
            echo "Pushing changes to remote repository..."
            git push "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" HEAD:${GITHUB_REF#refs/heads/}
            echo "changes_made=true" >> $GITHUB_OUTPUT
          fi
          
      # Step 5.1: Handle potential merge conflicts
      - name: Handle potential merge conflicts
        if: steps.commit_changes.outputs.changes_made == 'true'
        run: |
          # Check if there are merge conflicts
          if git status | grep -q "You have unmerged paths"; then
            echo "Detected merge conflicts. Attempting to resolve..."

            # Auto-resolve CHANGELOG.csv
            if git status | grep -q "CHANGELOG.csv"; then
              echo "Resolving conflict in CHANGELOG.csv..."
              git show :2:html_files/CHANGELOG.csv > /tmp/ours_changelog.csv
              git show :3:html_files/CHANGELOG.csv > /tmp/theirs_changelog.csv
              head -n 1 /tmp/ours_changelog.csv > /tmp/merged_changelog.csv
              (tail -n +2 /tmp/ours_changelog.csv && tail -n +2 /tmp/theirs_changelog.csv) | sort | uniq >> /tmp/merged_changelog.csv
              cp /tmp/merged_changelog.csv html_files/CHANGELOG.csv
              git add html_files/CHANGELOG.csv
              echo "CHANGELOG.csv conflict resolved automatically."
            fi

            # Auto-resolve .html and .svg conflicts by taking the new generated file
            for f in $(git status --porcelain | grep '^UU ' | awk '{print $2}' | grep -E '\\.(html|svg)$'); do
              echo "Auto-resolving $f by taking the new generated file"
              git add "$f"
            done

            # Continue with the rebase
            if git rebase --continue; then
              echo "Rebase completed successfully after resolving conflicts."
            else
              echo "Could not continue rebase. Please check the repository."
              exit 1
            fi
          else
            echo "No merge conflicts detected."
          fi
          
      # Step 5.2: Push changes after handling conflicts
      - name: Push changes
        if: steps.commit_changes.outputs.changes_made == 'true'
        run: |
          # Try to push changes, with multiple retries for transient issues
          MAX_RETRIES=3
          RETRY_COUNT=0
          PUSH_SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$PUSH_SUCCESS" = false ]; do
            if git push origin main; then
              echo "Successfully pushed changes to remote repository."
              PUSH_SUCCESS=true
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Push failed. Retrying in 5 seconds... (Attempt $RETRY_COUNT of $MAX_RETRIES)"
                sleep 5
                
                # Pull latest changes again before retrying
                echo "Pulling latest changes before retry..."
                git pull --rebase origin main || true
              else
                echo "Failed to push after $MAX_RETRIES attempts."
                echo "::warning::Failed to push changes automatically. Please check repository."
              fi
            fi
          done

      # Step 6: Upload changelog to SharePoint
      - name: Upload changelog to SharePoint
        if: steps.commit_changes.outputs.changes_made == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            try {
              const https = require('https');
              console.log('Preparing to upload changelog to SharePoint...');
              
              // Read and format the changelog file for SharePoint
              const changelogPath = path.join(process.env.GITHUB_WORKSPACE, 'html_files', 'CHANGELOG.csv');
              console.log(`Reading changelog from: ${changelogPath}`);
              const rawContent = fs.readFileSync(changelogPath, 'utf8');
              
              // Format the changelog with proper headers and content
              // First, parse the existing CSV
              const lines = rawContent.split('\n').filter(line => line.trim());
              const header = lines[0]; // Get header row
              const dataRows = lines.slice(1); // Get data rows
              
              // Create a properly formatted CSV with all the needed columns in the requested order
              // Date, Time, Diagram, Action, File, Commit Message, Version, Commit Hash
              let fileContent = 'Date,Time,Diagram,Action,File,Commit Message,Version,Commit Hash\n';
              
              // Add the data rows with today's upload date
              const today = new Date().toLocaleDateString('en-GB', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric'
              }); // Format as DD.MM.YYYY
              
              // Process each row to handle the changed column ordering
              dataRows.forEach(row => {
                if (row.trim()) {
                  // Using a more robust CSV parsing approach
                  try {
                    // First, parse the CSV properly using a regex that handles quoted fields with commas
                    const parseCSV = (text) => {
                      const result = [];
                      const regex = /("[^"]*"|[^,"\r\n]+)(?=,|\r\n|$)|^(?=,|$)|,(?=,|$)/g;
                      let m;
                      
                      while ((m = regex.exec(text)) !== null) {
                        // Remove quotes if the field is quoted
                        let field = m[1] || '';
                        if (field.startsWith('"') && field.endsWith('"')) {
                          field = field.substring(1, field.length - 1);
                        }
                        result.push(field);
                      }
                      
                      return result;
                    };
                    
                    const extractedCols = parseCSV(row);
                    
                    // Ensure we have enough columns and handle missing values
                    while (extractedCols.length < 9) {
                      extractedCols.push('');
                    }
                    
                    // For reference, original columns are:
                    // [0]Date, [1]Time, [2]User, [3]Diagram, [4]Action, [5]File, [6]Commit Message, [7]Version, [8]Commit Hash
                    
                    // Keeping same format, just removing the SharePoint Upload Date:
                    // [0]Date, [1]Time, [2]Diagram, [3]Action, [4]File, [5]Commit Message, [6]Version, [7]Commit Hash
                    
                    // Create a properly formatted CSV row with quotes around each field
                    const formattedRow = [
                      extractedCols[0],                      // Date
                      extractedCols[1],                      // Time
                      `"${(extractedCols[3] || '').replace(/"/g, '""')}"`,  // Diagram
                      `"${(extractedCols[4] || '').replace(/"/g, '""')}"`,  // Action
                      `"${(extractedCols[5] || '').replace(/"/g, '""')}"`,  // File
                      `"${(extractedCols[6] || '').replace(/"/g, '""')}"`,  // Commit Message
                      extractedCols[7] || '',                // Version
                      extractedCols[8] || ''                 // Commit Hash
                    ].join(',');
                    
                    fileContent += formattedRow + '\n';
                  } catch (error) {
                    console.error(`Error processing CSV row: ${row}`, error);
                    // Skip this row if there's an error
                  }
                }
              });
              
              console.log(`Formatted changelog with ${dataRows.length} entries`);
              
              // Function to make HTTP requests with promises
              const httpRequest = (options, postData) => {
                return new Promise((resolve, reject) => {
                  const req = https.request(options, (res) => {
                    let data = '';
                    res.on('data', (chunk) => { data += chunk; });
                    res.on('end', () => {
                      if (res.statusCode >= 200 && res.statusCode < 300) {
                        try {
                          resolve(data.length > 0 ? JSON.parse(data) : {});
                        } catch (e) {
                          resolve(data); // Not JSON, return as string
                        }
                      } else {
                        reject(new Error(`HTTP Error: ${res.statusCode} ${data}`));
                      }
                    });
                  });
                  
                  req.on('error', reject);
                  
                  if (postData) {
                    req.write(postData);
                  }
                  req.end();
                });
              };
              
              // Step 1: Get access token with proper SharePoint permissions
              console.log('Getting access token...');
              const tokenBody = new URLSearchParams({
                client_id: process.env.CLIENT_ID,
                scope: 'https://graph.microsoft.com/.default',
                client_secret: process.env.CLIENT_SECRET,
                grant_type: 'client_credentials'
              }).toString();
              
              const tokenOptions = {
                method: 'POST',
                hostname: 'login.microsoftonline.com',
                path: `/${process.env.TENANT_ID}/oauth2/v2.0/token`,
                headers: {
                  'Content-Type': 'application/x-www-form-urlencoded',
                  'Content-Length': Buffer.byteLength(tokenBody)
                }
              };
              
              // Get token
              const tokenData = await httpRequest(tokenOptions, tokenBody);
              console.log('Access token obtained');
              
              // Step 2: Get drives if needed
              // Force drive ID detection regardless of configured value due to previous errors
              console.log('Attempting to detect SharePoint drives automatically...');
              
              // Verify the site ID from secrets
              try {
                console.log(`Verifying site ID from secret: ${process.env.SITE_ID}`);
                
                const siteOptions = {
                  method: 'GET',
                  hostname: 'graph.microsoft.com',
                  path: `/v1.0/sites/${process.env.SITE_ID}`,
                  headers: {
                    'Authorization': `Bearer ${tokenData.access_token}`,
                    'Accept': 'application/json'
                  }
                };
                
                const siteData = await httpRequest(siteOptions);
                console.log(`Site found: ${siteData.displayName || siteData.name}`);
              } catch (siteError) {
                console.error('Error verifying site:', siteError.message);
                console.log('Trying alternative site path format...');
                // If the site ID doesn't work, try a different format
                const originalSiteId = process.env.SITE_ID;
                try {
                  // Try sites/SiteName format
                  if (!originalSiteId.startsWith('sites/')) {
                    process.env.SITE_ID = `sites/${originalSiteId.split('/').pop()}`;
                  } else {
                    // Or try domain,sites,SiteName format
                    process.env.SITE_ID = `frostaag.sharepoint.com,${originalSiteId.replace('/', ',')}`;
                  }
                  console.log(`Using alternative site ID format: ${process.env.SITE_ID}`);
                } catch (formatError) {
                  console.error('Error reformatting site ID:', formatError);
                  // Keep the original if parsing fails
                }
              }
              
              // Now get the list of drives
              const drivesOptions = {
                method: 'GET',
                hostname: 'graph.microsoft.com',
                path: `/v1.0/sites/${process.env.SITE_ID}/drives`,
                headers: {
                  'Authorization': `Bearer ${tokenData.access_token}`,
                  'Accept': 'application/json'
                }
              };
              
              console.log(`Requesting drives list from: ${drivesOptions.path}`);
              const drivesData = await httpRequest(drivesOptions);
              
              if (!drivesData.value || drivesData.value.length === 0) {
                throw new Error(`No drives found for site: ${process.env.SITE_ID}`);
              }
              
              console.log('Available drives:');
              drivesData.value.forEach(d => console.log(`- ${d.name}: ${d.id}`));
              
              // Try to find the Documents drive - prioritize "Shared Documents" 
              console.log('Looking for document library named "Shared Documents"');
              const documentsDrive = drivesData.value.find(d => 
                d.name === 'Shared Documents' || 
                d.name === 'Documents' || 
                d.name.includes('Document')
              );
              
              let driveId;
              if (documentsDrive) {
                driveId = documentsDrive.id;
                console.log(`Selected document library: ${documentsDrive.name} (${driveId})`);
              } else {
                // Fall back to first drive
                driveId = drivesData.value[0].id;
                console.log(`No document library found, using first available drive: ${drivesData.value[0].name} (${driveId})`);
              }
              
              // Step 3: Upload the file - use consistent filename instead of date-stamped
              const fileName = 'Diagrams_Changelog.csv';  // Fixed filename that will be overwritten each time
              const folderPath = 'Diagrams';  // Target folder in SharePoint DatasphereFileStorage site
              console.log(`Uploading changelog as ${fileName} to folder "${folderPath}" in drive ${driveId}...`);
              
              // Create the folder if it doesn't exist
              try {
                const folderCheckOptions = {
                  method: 'GET',
                  hostname: 'graph.microsoft.com',
                  path: `/v1.0/sites/${process.env.SITE_ID}/drives/${driveId}/root:/${folderPath}`,
                  headers: {
                    'Authorization': `Bearer ${tokenData.access_token}`,
                    'Accept': 'application/json'
                  }
                };
                
                // Check if folder exists
                try {
                  await httpRequest(folderCheckOptions);
                  console.log(`Folder "${folderPath}" already exists`);
                } catch (folderError) {
                  if (folderError.message.includes('404')) {
                    // Folder doesn't exist, create it
                    console.log(`Creating folder "${folderPath}"...`);
                    const createFolderOptions = {
                      method: 'PATCH',
                      hostname: 'graph.microsoft.com',
                      path: `/v1.0/sites/${process.env.SITE_ID}/drives/${driveId}/root/children`,
                      headers: {
                        'Authorization': `Bearer ${tokenData.access_token}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                      }
                    };
                    
                    await httpRequest(createFolderOptions, JSON.stringify({
                      name: folderPath,
                      folder: {},
                      '@microsoft.graph.conflictBehavior': 'rename'
                    }));
                    console.log(`Folder "${folderPath}" created successfully`);
                  } else {
                    throw folderError;
                  }
                }
              } catch (folderCreateError) {
                console.error(`Error managing folder "${folderPath}":`, folderCreateError.message);
                console.log('Will attempt to upload to the folder anyway...');
              }
              
              // Upload file to the specified folder
              const uploadOptions = {
                method: 'PUT',
                hostname: 'graph.microsoft.com',
                path: `/v1.0/sites/${process.env.SITE_ID}/drives/${driveId}/root:/${folderPath}/${fileName}:/content`,
                headers: {
                  'Authorization': `Bearer ${tokenData.access_token}`,
                  'Content-Type': 'text/csv',
                  'Content-Length': Buffer.byteLength(fileContent)
                }
              };
              
              const uploadData = await httpRequest(uploadOptions, fileContent);
              console.log('Successfully uploaded changelog to SharePoint');
              console.log(`File URL: ${uploadData.webUrl}`);
              
            } catch (error) {
              console.error('Error uploading to SharePoint:', error.message);
              // Don't fail the workflow if SharePoint upload fails
            }
        env:
          TENANT_ID: ${{ secrets.TENANT_ID }}
          CLIENT_ID: ${{ secrets.CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.CLIENT_SECRET }}
          SITE_ID: ${{ secrets.SITE_ID }}
          DRIVE_ID: ${{ secrets.DRIVE_ID || 'auto' }}
  
  # Notifications for both success and failure
  teams-notification:
    needs: convert
    runs-on: ubuntu-latest
    if: ${{ always() }}  # Run this job whether the main job succeeds or fails
    
    steps:
      # This step runs only on success
      - name: Send Teams success notification
        if: ${{ needs.convert.result == 'success' }}
        run: |
          # Create JSON payload for Teams webhook
          PAYLOAD=$(cat << EOF
          {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "themeColor": "00FF00",
            "summary": "Draw.io Conversion Workflow Succeeded",
            "sections": [
              {
                "activityTitle": "✅ Draw.io Conversion Workflow Completed",
                "activitySubtitle": "Diagrams were successfully processed",
                "facts": [
                  {
                    "name": "Repository",
                    "value": "${{ github.repository }}"
                  },
                  {
                    "name": "Workflow",
                    "value": "${{ github.workflow }}"
                  },
                  {
                    "name": "Commit",
                    "value": "${{ github.sha }}"
                  },
                  {
                    "name": "Triggered by",
                    "value": "${{ github.actor }}"
                  }
                ],
                "markdown": true
              }
            ],
            "potentialAction": [
              {
                "@type": "OpenUri",
                "name": "View Workflow Run",
                "targets": [
                  {
                    "os": "default",
                    "uri": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                ]
              }
            ]
          }
          EOF
          )
          
          # Send the payload to Teams webhook
          curl -H "Content-Type: application/json" -d "$PAYLOAD" "${{ secrets.TEAMS_WEBHOOK }}"

      # This step runs only on failure
      - name: Send Teams failure notification
        if: ${{ needs.convert.result == 'failure' }}
        run: |
          # Create JSON payload for Teams webhook
          PAYLOAD=$(cat << EOF
          {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "themeColor": "FF0000",
            "summary": "Draw.io Conversion Workflow Failed",
            "sections": [
              {
                "activityTitle": "❌ Draw.io Conversion Workflow Failed",
                "activitySubtitle": "GitHub Actions workflow run failed",
                "facts": [
                  {
                    "name": "Repository",
                    "value": "${{ github.repository }}"
                  },
                  {
                    "name": "Workflow",
                    "value": "${{ github.workflow }}"
                  },
                  {
                    "name": "Commit",
                    "value": "${{ github.sha }}"
                  },
                  {
                    "name": "Triggered by",
                    "value": "$TRIGGERER_NAME"
                  },
                  {
                    "name": "Run ID",
                    "value": "${{ github.run_id }}"
                  }
                ],
                "markdown": true
              }
            ],
            "potentialAction": [
              {
                "@type": "OpenUri",
                "name": "View Workflow Run",
                "targets": [
                  {
                    "os": "default",
                    "uri": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                ]
              }
            ]
          }
          EOF
          )
          
          # Send the payload to Teams webhook
          curl -H "Content-Type: application/json" -d "$PAYLOAD" "${{ secrets.TEAMS_WEBHOOK }}"
      # Step 2: Check for file changes
      - name: Check for changed .drawio files
        id: check_files
        run: |
          echo "Checking for changed .drawio files..."
          
          # Initialize output
          CHANGES_DETECTED=false
          
          # Method 1: Check for changes between HEAD and HEAD^
          echo "Trying method 1: git diff HEAD^ HEAD"
          if git diff --name-only HEAD^ HEAD 2>/dev/null | grep -q "\.drawio$"; then
            CHANGES_DETECTED=true
            echo "Changes detected using method 1"
          fi
          
          # If method 1 failed, try method 2 (useful for initial commits)
          if [ "$CHANGES_DETECTED" = false ]; then
            echo "Trying method 2: git diff-tree (for initial commits)"
            if git diff-tree --no-commit-id --name-only -r HEAD 2>/dev/null | grep -q "\.drawio$"; then
              CHANGES_DETECTED=true
              echo "Changes detected using method 2"
            fi
          fi
          
          # If still no changes detected, try method 3 (list all .drawio files on a new repo)
          if [ "$CHANGES_DETECTED" = false ]; then
            echo "Trying method 3: check for existence of any .drawio files"
            if find . -name "*.drawio" -type f 2>/dev/null | grep -q "\.drawio$"; then
              CHANGES_DETECTED=true
              echo "Changes detected using method 3 (found .drawio files)"
            fi
          fi
          
          # Set the output
          if [ "$CHANGES_DETECTED" = true ]; then
            echo "files_changed=true" >> $GITHUB_OUTPUT
            echo ".drawio files were changed or found in this commit"
            
            # List the files that were changed/found for better debugging
            echo "Changed or found .drawio files:"
            git diff --name-only HEAD^ HEAD 2>/dev/null | grep "\.drawio$" || \
            git diff-tree --no-commit-id --name-only -r HEAD 2>/dev/null | grep "\.drawio$" || \
            find . -name "*.drawio" -type f | sort
          else
            echo "files_changed=false" >> $GITHUB_OUTPUT
            echo "No .drawio files were changed in this commit"
          fi
      # Step 3: Analyze and process new diagrams for auto ID assignment
      - name: Auto-assign IDs to new diagrams
        id: auto_id
        if: ${{ steps.check_files.outputs.files_changed == 'true' }}
        run: |
          # Initialize outputs
          echo "id_assigned=false" >> $GITHUB_OUTPUT
          echo "renamed_files=" >> $GITHUB_OUTPUT
          
          # Create a list to store renamed files
          RENAMED_FILES=()
          ID_ASSIGNED=false
          
          # Get list of changed Draw.io files in this commit using multiple methods
          echo "Getting list of .drawio files to process..."
          
          # Method 1: Standard diff (most commits)
          CHANGED_FILES=$(git diff --name-only HEAD^ HEAD 2>/dev/null | grep "\.drawio$" || echo "")
          
          # Method 2: For initial commits
          if [ -z "$CHANGED_FILES" ]; then
            CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r HEAD 2>/dev/null | grep "\.drawio$" || echo "")
            echo "Using diff-tree method for initial commit, found: $CHANGED_FILES"
          fi
          
          # Method 3: For new repositories, check all .drawio files
          if [ -z "$CHANGED_FILES" ]; then
            CHANGED_FILES=$(find . -name "*.drawio" -type f | sed 's|^\./||' || echo "")
            echo "Using find method for new repository, found: $CHANGED_FILES"
          fi
          
          echo "Draw.io files to process: $CHANGED_FILES"
          
          # Debug output
          echo "Current directory: $(pwd)"
          echo "Listing all .drawio files for reference:"
          find . -name "*.drawio" -type f | sort
          
          # Process each changed file to see if it needs ID assignment
          for file in $CHANGED_FILES; do
            # Make sure the file exists (useful if we're parsing git output)
            if [ ! -f "$file" ]; then
              echo "File not found: $file, skipping..."
              continue
            fi
            
            # Extract just the filename without path and extension
            base_name=$(basename "$file" .drawio)
            
            # Extra debug information
            echo "--------------------------------------------"
            echo "AUTO-ID PROCESSING: $file"
            echo "Base name: $base_name"
            echo "File exists: $([ -f "$file" ] && echo "Yes" || echo "No")"
            echo "File size: $(wc -c < "$file") bytes"
            echo "--------------------------------------------"
            
            # Test each pattern (for debugging)
            echo "Testing naming patterns:"
            if [[ "$base_name" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.\ .* ]]; then
              echo "✓ Pattern 1 (X.Y.Z. Name) matches: Complete ID with dot"
            else
              echo "✗ Pattern 1 (X.Y.Z. Name) does NOT match"
            fi
            
            if [[ "$base_name" =~ ^[0-9]+\.[0-9]+\.\ .* ]]; then
              echo "✓ Pattern 2 (X.Y. Name) matches: Partial ID with dot"
            else
              echo "✗ Pattern 2 (X.Y. Name) does NOT match"
            fi
            
            if [[ "$base_name" =~ ^[0-9]+\.[0-9]+\ .* ]]; then
              echo "✓ Pattern 3 (X.Y Name) matches: Partial ID without dot - NEEDS AUTO-ID"
            else
              echo "✗ Pattern 3 (X.Y Name) does NOT match"
            fi
            
            # Check file patterns in order using simplified approach
            
            # Extract first part (prefix) and rest (name)
            PREFIX_PART=${base_name%% *}
            NAME_PART=${base_name#* }
            
            # Debug
            echo "  Prefix Part: '$PREFIX_PART'"
            echo "  Name Part: '$NAME_PART'"
            
            # Patterns:
            # 1. X.Y.Z. Name - already has full ID with dot
            # 2. X.Y.Z Name - already has full ID without dot
            # 3. X.Y. Name - already has partial ID with dot
            # 4. X.Y Name - needs ID assignment (the pattern we're looking for)
            
            # Check if this is a file that needs ID assignment (X.Y Name format)
            # It should have exactly one dot, two numbers, and no dot after second number
            if [[ "$PREFIX_PART" == [0-9]*.[0-9]* && "$PREFIX_PART" != *. ]]; then
              # Count dots to make sure there's exactly one
              DOT_COUNT=$(echo "$PREFIX_PART" | tr -cd '.' | wc -c)
              if [ "$DOT_COUNT" -eq 1 ]; then
                echo "✅ Found file that needs auto-ID assignment: $file"
                
                # Simple extraction
                CATEGORY=${PREFIX_PART%%.*}
                DETAIL=${PREFIX_PART#*.}
                PREFIX="$CATEGORY.$DETAIL"
                NAME="$NAME_PART"
                
                # Debug extracted parts
                echo "Extracted parts:"
                echo "  Category: '$CATEGORY'"
                echo "  Detail: '$DETAIL'"
                echo "  Prefix: '$PREFIX'"
                echo "  Name: '$NAME'"
                
                # Find highest existing ID for this prefix
                HIGHEST_ID=0
                echo "Looking for existing diagrams with prefix $PREFIX..."
                
                # Safety check to avoid expanding to literal '*' if no files match
                shopt -s nullglob
                
                # Look for files matching the pattern X.Y.Z. format with different variations
                for existing in drawio_files/*.drawio; do
                  [ -f "$existing" ] || continue
                  
                  existing_base=$(basename "$existing" .drawio)
                  
                  # Pattern 1: X.Y.Z. Name format (with dot)
                  if [[ "$existing_base" =~ ^${PREFIX}\.([0-9]+)\. ]]; then
                    ID_PART="${BASH_REMATCH[1]}"
                    HIGHEST_ID=$((ID_PART > HIGHEST_ID ? ID_PART : HIGHEST_ID))
                    echo "Found existing diagram with higher ID: $existing_base (ID: $ID_PART)"
                  fi
                  
                  # Pattern 2: X.Y.ZName format (without dot before ID)
                  if [[ "$existing_base" =~ ^${PREFIX}([0-9]+)$ ]]; then
                    ID_PART="${BASH_REMATCH[1]}"
                    HIGHEST_ID=$((ID_PART > HIGHEST_ID ? ID_PART : HIGHEST_ID))
                    echo "Found existing diagram with higher ID (no dot): $existing_base (ID: $ID_PART)"
                  fi
                done
                
                # Restore nullglob
                shopt -u nullglob
                
                # Assign new ID
                if [ "$HIGHEST_ID" -gt 0 ]; then
                  NEW_ID=$((HIGHEST_ID + 1))
                  echo "Assigning new ID $NEW_ID to $file"
                  
                  # Rename file
                  NEW_FILENAME="${PREFIX}.${NEW_ID} ${NAME}.drawio"
                  echo "New filename: $NEW_FILENAME"
                  
                  # Perform the rename
                  git mv "$file" "$(dirname "$file")/$NEW_FILENAME"
                  
                  # Add to renamed files list
                  RENAMED_FILES+=("$NEW_FILENAME")
                  ID_ASSIGNED=true
                else
                  echo "No existing ID found, cannot assign new ID"
                fi
              else
                echo "✗ Prefix part does not match ID pattern or has multiple dots: $PREFIX_PART"
              fi
            else
              echo "✅ File already has ID or does not need ID assignment: $file"
            fi
          done
          
          # Set output variables
          echo "id_assigned=$ID_ASSIGNED" >> $GITHUB_OUTPUT
          echo "renamed_files=$(printf '%s|' "${RENAMED_FILES[@]}")" >> $GITHUB_OUTPUT
          echo "Processed ${#RENAMED_FILES[@]} files, ID assigned: $ID_ASSIGNED"
