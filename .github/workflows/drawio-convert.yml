name: Convert Draw.io Files

on:
  push:
    paths:
      - '**/*.drawio'
      - 'drawio_files/**'
  workflow_dispatch: # Enable manual triggering

# Add permissions needed for the workflow
permissions:
  contents: write

jobs:
  convert:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Check out the repository with history to detect changes
      - name: Check out the repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch all history to properly identify changed files

      # Step 2: Install dependencies
      - name: Install Draw.io and dependencies
        run: |
          sudo apt-get update
          # Use libasound2t64 instead of libasound2 for Ubuntu Noble (24.04)
          sudo apt-get install -y wget unzip xvfb libasound2t64 libgbm1 libnspr4 libnss3 libxss1
          wget https://github.com/jgraph/drawio-desktop/releases/download/v26.2.2/drawio-amd64-26.2.2.deb
          sudo apt-get -f install -y
          sudo dpkg -i drawio-amd64-26.2.2.deb || sudo apt-get -f install -y
          
      # Step 2.5: Add .drawio extension to files without extension
      - name: Add .drawio extension to files without extension
        run: |
          # Check if drawio_files directory exists
          if [ -d "drawio_files" ]; then
            echo "Checking for files without extension in drawio_files directory..."
            
            # First, make sure we have the latest changes from remote
            echo "Fetching latest changes from remote repository..."
            git fetch "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
            
            # Find files without extension in drawio_files directory
            # Use find command with null separator to handle filenames with spaces
            find drawio_files -type f -not -path "*/\.*" -print0 | while IFS= read -r -d $'\0' file; do
              # Check if filename contains a dot (which indicates an extension)
              filename=$(basename "$file")
              if [[ "$filename" != *.* ]]; then
                # Check if the file actually exists before trying to rename it
                if [ -f "$file" ]; then
                  echo "Adding .drawio extension to: $file"
                  
                  # Check if target file already exists (in case we've already renamed it)
                  if [ -f "${file}.drawio" ]; then
                    echo "Warning: ${file}.drawio already exists. Skipping rename."
                  else
                    # Rename the file
                    mv "$file" "${file}.drawio"
                    
                    # Add and commit the renamed file
                    git add "${file}.drawio"
                    # Also remove the original file if git still tracks it
                    git rm --ignore-unmatch "$file" > /dev/null 2>&1
                    
                    git config --local user.name "github-actions[bot]"
                    git config --local user.email "github-actions[bot]@users.noreply.github.com"
                    git commit -m "Add .drawio extension to $filename"
                    
                    # Push changes immediately to avoid conflicts
                    echo "Pushing changes to remote repository..."
                    git push "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" HEAD:${GITHUB_REF#refs/heads/}
                  fi
                else
                  echo "Warning: File $file no longer exists, skipping."
                fi
              fi
            done
          else
            echo "drawio_files directory not found, skipping extension check."
          fi

      # Step 3: Create output directories
      - name: Create output folders
        run: |
          mkdir -p svg_files html_files
          
          # Initialize CSV changelogs with headers if they don't exist
          if [ ! -f "svg_files/CHANGELOG.csv" ]; then
            echo "Date,Time,User,Diagram,Action,File,Commit Message,Version" > svg_files/CHANGELOG.csv
          fi
          if [ ! -f "html_files/CHANGELOG.csv" ]; then
            echo "Date,Time,User,Diagram,Action,File,Commit Message,Version" > html_files/CHANGELOG.csv
          fi

      # Step 4: Convert .drawio files to SVG and wrap them in HTML
      - name: Convert Draw.io files
        run: |
          # Set up virtual display for headless operation
          Xvfb :99 -screen 0 1024x768x16 &
          export DISPLAY=:99
          sleep 1 # Give Xvfb time to start

          # Use a different approach - temporary script
          cat > /tmp/convert-drawio.sh << 'EOL'
          #!/bin/bash
          input_file=$1
          output_file=$2
          drawio -x -f svg -o "$output_file" "$input_file"
          EOL
          chmod +x /tmp/convert-drawio.sh

          # Set debug output to help troubleshoot
          echo "Current directory: $(pwd)"
          echo "Listing drawio_files directory:"
          ls -la drawio_files || echo "drawio_files directory not found"
          
          # For first run or debugging, process all files regardless of changes
          echo "Processing all .drawio files to generate complete changelog..."
          
          # Find all .drawio files and process them - search in current dir AND drawio_files dir if it exists
          find . -type f -name "*.drawio" -print0 | while IFS= read -r -d $'\0' file; do
            # Get the base filename without extension, preserving spaces
            base=$(basename "$file" .drawio)
            rel_path=$(echo "$file" | sed 's|^\./||')
            echo "Full file path: $file, Relative path: $rel_path"
            
            # Always process all files to ensure complete changelog
            FILE_CHANGED=true
            echo "Processing file: $file"

            mkdir -p "svg_files"
            output_path="svg_files/${base}.svg"
            
            # Run the conversion with xvfb-run - quote variables to handle spaces properly
            xvfb-run -a /tmp/convert-drawio.sh "$file" "$output_path"
            
            # Check if conversion succeeded
            if [ ! -f "$output_path" ]; then
              echo "Failed to convert $file to SVG. Trying alternative method..."
              # Alternative approach using node directly if installed with drawio
              xvfb-run -a drawio -x -f svg -o "$output_path" "$file"
            fi

            # Create an HTML wrapper
            echo '<!DOCTYPE html>' > "html_files/${base}.html"
            echo '<html lang="en">' >> "html_files/${base}.html"
            echo '<head>' >> "html_files/${base}.html"
            echo '  <meta charset="UTF-8">' >> "html_files/${base}.html"
            echo "  <title>${base}</title>" >> "html_files/${base}.html"
            echo '  <style>' >> "html_files/${base}.html"
            echo '    body { margin: 0; padding: 0; }' >> "html_files/${base}.html"
            echo '    svg { max-width: 100%; height: auto; display: block; }' >> "html_files/${base}.html"
            echo '  </style>' >> "html_files/${base}.html"
            echo '</head>' >> "html_files/${base}.html"
            echo '<body>' >> "html_files/${base}.html"

            cat "svg_files/${base}.svg" >> "html_files/${base}.html"

            echo '</body>' >> "html_files/${base}.html"
            echo '</html>' >> "html_files/${base}.html"              # Only log the changes if this file was modified in this commit
            if [ "$FILE_CHANGED" = true ]; then
              # Log the changes in CSV format with date as dd.mm.yyyy and full name
              # Get the full name of the author (or committer) of the latest commit that modified this file
              AUTHOR=$(git log -1 --format="%aN" -- "$file" || echo "${{ github.actor }}")
              # Get the commit message for this file's change
              COMMIT_MSG=$(git log -1 --format="%s" -- "$file" || echo "No commit message")
              # Escape any quotes in the commit message for CSV format
              COMMIT_MSG=$(echo "$COMMIT_MSG" | sed 's/"/""/g')
              FORMATTED_DATE=$(date +"%d.%m.%Y")
              FORMATTED_TIME=$(date +"%H:%M:%S")
              
              # Check if this is a new diagram or a modification
              # First try with git history, fallback to file existence check
              if git ls-files --error-unmatch "svg_files/${base}.svg" &>/dev/null 2>/dev/null; then
                CHANGE_TYPE="Modified"
              else
                # Fallback to direct file check before our current conversion
                if [ -f "svg_files/${base}.svg.old" ]; then
                  CHANGE_TYPE="Modified"
                else
                  CHANGE_TYPE="New"
                fi
              fi
              
              # Make sure changelog directory exists
              mkdir -p svg_files html_files
              
              # Make debug output to understand what's happening
              echo "Creating changelog entries for: $base (${CHANGE_TYPE})"
              
              # Get enhanced version information using semantic versioning light (MAJOR.MINOR)
              # Use git history to determine if this is a major or minor change
              # Start with the commit message - if it contains keywords, categorize the change
              MAJOR_KEYWORDS="redesign|new version|complete|refactor|overhaul|major|added"
              MINOR_UPDATE_KEYWORDS="update|fix|adjust|tweak|enhance|improve|minor"
              
              # Default to standard minor change (increment minor version)
              IS_MAJOR_CHANGE=0
              CHANGE_DESCRIPTION="Change"
              
              # Check commit message for major change keywords (case insensitive)
              if echo "$COMMIT_MSG" | grep -iE "$MAJOR_KEYWORDS" > /dev/null; then
                IS_MAJOR_CHANGE=1
                CHANGE_DESCRIPTION="Major Change"
                echo "Detected major change based on commit message keywords"
              # Check for minor update keywords (case insensitive)
              elif echo "$COMMIT_MSG" | grep -iE "$MINOR_UPDATE_KEYWORDS" > /dev/null; then
                CHANGE_DESCRIPTION="Update"
                echo "Detected update based on commit message keywords"
              fi
              
              # Get current minor and major versions from git history
              MINOR_VERSION=$(git log --follow --oneline -- "$file" | wc -l | tr -d ' ')
              MAJOR_VERSION=1
              
              # Check if file exists in previous commits to determine major version
              PREV_VERSIONS=$(git log --follow --pretty=format:"%H" -- "$file")
              if [ -n "$PREV_VERSIONS" ]; then
                # Count the number of commits containing major change keywords
                MAJOR_VERSION=$(git log --follow --pretty=format:"%s" -- "$file" | grep -iE "$MAJOR_KEYWORDS" | wc -l | tr -d ' ')
                # Add 1 because we start at version 1.0
                MAJOR_VERSION=$((MAJOR_VERSION + 1))
              fi
              
              # Handle new diagrams - they start at 1.0
              if [ "$CHANGE_TYPE" = "New" ]; then
                VERSION="1.0"
              else
                # For modifications, use the major.minor scheme
                if [ "$IS_MAJOR_CHANGE" -eq 1 ]; then
                  # Major change, increment major version, reset minor to 0
                  VERSION="${MAJOR_VERSION}.0"
                else
                  # Minor change, keep major version, increment minor
                  VERSION="${MAJOR_VERSION}.$((MINOR_VERSION - 1))"
                fi
              fi
              
              # Simplified action description: New for new files, Update for modifications
              if [ "$CHANGE_TYPE" = "New" ]; then
                ACTION_DESC="New"
              else
                ACTION_DESC="Modified (Update)"
              fi
              
              # Write to changelogs with the new column order and diagram name
              # Date, Time, User, Diagram, Action, File, Commit Message, Version
              # Properly escape all fields to ensure CSV format integrity
              echo "$FORMATTED_DATE,$FORMATTED_TIME,\"$AUTHOR\",\"${base}\",\"$ACTION_DESC\",\"${base}.drawio to ${base}.svg\",\"$COMMIT_MSG\",\"$VERSION\"" >> svg_files/CHANGELOG.csv
              echo "$FORMATTED_DATE,$FORMATTED_TIME,\"$AUTHOR\",\"${base}\",\"$ACTION_DESC\",\"${base}.drawio to ${base}.html\",\"$COMMIT_MSG\",\"$VERSION\"" >> html_files/CHANGELOG.csv
              echo "Added entries to changelog for $file ($ACTION_DESC)"
            fi
          done

      # Step 5: Commit and push changes
      - name: Commit and push changes
        id: commit_changes
        run: |
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git add svg_files html_files
          # Only commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "changes_made=false" >> $GITHUB_OUTPUT
          else
            git commit -m "Auto-converted draw.io files"
            # Use GitHub token for authentication
            git push "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" HEAD:${GITHUB_REF#refs/heads/}
            echo "changes_made=true" >> $GITHUB_OUTPUT
          fi
          
      # Step 6: Upload changelog to SharePoint
      - name: Upload changelog to SharePoint
        if: steps.commit_changes.outputs.changes_made == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            try {
              const https = require('https');
              console.log('Preparing to upload changelog to SharePoint...');
              
              // Read and format the changelog file for SharePoint
              const changelogPath = path.join(process.env.GITHUB_WORKSPACE, 'html_files', 'CHANGELOG.csv');
              console.log(`Reading changelog from: ${changelogPath}`);
              const rawContent = fs.readFileSync(changelogPath, 'utf8');
              
              // Format the changelog with proper headers and content
              // First, parse the existing CSV
              const lines = rawContent.split('\n').filter(line => line.trim());
              const header = lines[0]; // Get header row
              const dataRows = lines.slice(1); // Get data rows
              
              // Create a properly formatted CSV with all the needed columns in the requested order
              // Date, Time, Diagram, Action, File, Commit Message, Version, SharePoint Upload Date
              let fileContent = 'Date,Time,Diagram,Action,File,Commit Message,Version,SharePoint Upload Date\n';
              
              // Add the data rows with today's upload date
              const today = new Date().toLocaleDateString('en-GB', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric'
              }); // Format as DD.MM.YYYY
              
              // Process each row to handle the changed column ordering
              dataRows.forEach(row => {
                if (row.trim()) {
                  // Using a more robust CSV parsing approach
                  try {
                    // First, parse the CSV properly using a regex that handles quoted fields with commas
                    const parseCSV = (text) => {
                      const result = [];
                      const regex = /("[^"]*"|[^,"\r\n]+)(?=,|\r\n|$)|^(?=,|$)|,(?=,|$)/g;
                      let m;
                      
                      while ((m = regex.exec(text)) !== null) {
                        // Remove quotes if the field is quoted
                        let field = m[1] || '';
                        if (field.startsWith('"') && field.endsWith('"')) {
                          field = field.substring(1, field.length - 1);
                        }
                        result.push(field);
                      }
                      
                      return result;
                    };
                    
                    const extractedCols = parseCSV(row);
                    
                    // Ensure we have enough columns and handle missing values
                    while (extractedCols.length < 8) {
                      extractedCols.push('');
                    }
                    
                    // For reference, original columns are:
                    // [0]Date, [1]Time, [2]User, [3]Diagram, [4]Action, [5]File, [6]Commit Message, [7]Version
                    
                    // New format:
                    // [0]Date, [1]Time, [2]Diagram, [3]Action, [4]File, [5]Commit Message, [6]Version, [7]SharePoint Upload Date
                    
                    // Create a properly formatted CSV row with quotes around each field
                    const formattedRow = [
                      extractedCols[0],                      // Date
                      extractedCols[1],                      // Time
                      `"${extractedCols[3].replace(/"/g, '""')}"`,  // Diagram
                      `"${extractedCols[4].replace(/"/g, '""')}"`,  // Action
                      `"${extractedCols[5].replace(/"/g, '""')}"`,  // File
                      `"${extractedCols[6].replace(/"/g, '""')}"`,  // Commit Message
                      extractedCols[7],                      // Version
                      today                                  // SharePoint Upload Date
                    ].join(',');
                    
                    fileContent += formattedRow + '\n';
                  } catch (error) {
                    console.error(`Error processing CSV row: ${row}`, error);
                    // Skip this row if there's an error
                  }
                }
              });
              
              console.log(`Formatted changelog with ${dataRows.length} entries and SharePoint upload date column`);
              
              // Function to make HTTP requests with promises
              const httpRequest = (options, postData) => {
                return new Promise((resolve, reject) => {
                  const req = https.request(options, (res) => {
                    let data = '';
                    res.on('data', (chunk) => { data += chunk; });
                    res.on('end', () => {
                      if (res.statusCode >= 200 && res.statusCode < 300) {
                        try {
                          resolve(data.length > 0 ? JSON.parse(data) : {});
                        } catch (e) {
                          resolve(data); // Not JSON, return as string
                        }
                      } else {
                        reject(new Error(`HTTP Error: ${res.statusCode} ${data}`));
                      }
                    });
                  });
                  
                  req.on('error', reject);
                  
                  if (postData) {
                    req.write(postData);
                  }
                  req.end();
                });
              };
              
              // Step 1: Get access token with proper SharePoint permissions
              console.log('Getting access token...');
              const tokenBody = new URLSearchParams({
                client_id: process.env.CLIENT_ID,
                scope: 'https://graph.microsoft.com/.default',
                client_secret: process.env.CLIENT_SECRET,
                grant_type: 'client_credentials'
              }).toString();
              
              const tokenOptions = {
                method: 'POST',
                hostname: 'login.microsoftonline.com',
                path: `/${process.env.TENANT_ID}/oauth2/v2.0/token`,
                headers: {
                  'Content-Type': 'application/x-www-form-urlencoded',
                  'Content-Length': Buffer.byteLength(tokenBody)
                }
              };
              
              // Get token
              const tokenData = await httpRequest(tokenOptions, tokenBody);
              console.log('Access token obtained');
              
              // Step 2: Get drives if needed
              // Force drive ID detection regardless of configured value due to previous errors
              console.log('Attempting to detect SharePoint drives automatically...');
              
              // Verify the site ID from secrets
              try {
                console.log(`Verifying site ID from secret: ${process.env.SITE_ID}`);
                
                const siteOptions = {
                  method: 'GET',
                  hostname: 'graph.microsoft.com',
                  path: `/v1.0/sites/${process.env.SITE_ID}`,
                  headers: {
                    'Authorization': `Bearer ${tokenData.access_token}`,
                    'Accept': 'application/json'
                  }
                };
                
                const siteData = await httpRequest(siteOptions);
                console.log(`Site found: ${siteData.displayName || siteData.name}`);
              } catch (siteError) {
                console.error('Error verifying site:', siteError.message);
                console.log('Trying alternative site path format...');
                // If the site ID doesn't work, try a different format
                const originalSiteId = process.env.SITE_ID;
                try {
                  // Try sites/SiteName format
                  if (!originalSiteId.startsWith('sites/')) {
                    process.env.SITE_ID = `sites/${originalSiteId.split('/').pop()}`;
                  } else {
                    // Or try domain,sites,SiteName format
                    process.env.SITE_ID = `frostaag.sharepoint.com,${originalSiteId.replace('/', ',')}`;
                  }
                  console.log(`Using alternative site ID format: ${process.env.SITE_ID}`);
                } catch (formatError) {
                  console.error('Error reformatting site ID:', formatError);
                  // Keep the original if parsing fails
                }
              }
              
              // Now get the list of drives
              const drivesOptions = {
                method: 'GET',
                hostname: 'graph.microsoft.com',
                path: `/v1.0/sites/${process.env.SITE_ID}/drives`,
                headers: {
                  'Authorization': `Bearer ${tokenData.access_token}`,
                  'Accept': 'application/json'
                }
              };
              
              console.log(`Requesting drives list from: ${drivesOptions.path}`);
              const drivesData = await httpRequest(drivesOptions);
              
              if (!drivesData.value || drivesData.value.length === 0) {
                throw new Error(`No drives found for site: ${process.env.SITE_ID}`);
              }
              
              console.log('Available drives:');
              drivesData.value.forEach(d => console.log(`- ${d.name}: ${d.id}`));
              
              // Try to find the Documents drive - prioritize "Shared Documents" 
              console.log('Looking for document library named "Shared Documents"');
              const documentsDrive = drivesData.value.find(d => 
                d.name === 'Shared Documents' || 
                d.name === 'Documents' || 
                d.name.includes('Document')
              );
              
              let driveId;
              if (documentsDrive) {
                driveId = documentsDrive.id;
                console.log(`Selected document library: ${documentsDrive.name} (${driveId})`);
              } else {
                // Fall back to first drive
                driveId = drivesData.value[0].id;
                console.log(`No document library found, using first available drive: ${drivesData.value[0].name} (${driveId})`);
              }
              
              // Step 3: Upload the file - use consistent filename instead of date-stamped
              const fileName = 'Diagrams_Changelog.csv';  // Fixed filename that will be overwritten each time
              const folderPath = 'Diagrams';  // Target folder in SharePoint DatasphereFileStorage site
              console.log(`Uploading changelog as ${fileName} to folder "${folderPath}" in drive ${driveId}...`);
              
              // Create the folder if it doesn't exist
              try {
                const folderCheckOptions = {
                  method: 'GET',
                  hostname: 'graph.microsoft.com',
                  path: `/v1.0/sites/${process.env.SITE_ID}/drives/${driveId}/root:/${folderPath}`,
                  headers: {
                    'Authorization': `Bearer ${tokenData.access_token}`,
                    'Accept': 'application/json'
                  }
                };
                
                // Check if folder exists
                try {
                  await httpRequest(folderCheckOptions);
                  console.log(`Folder "${folderPath}" already exists`);
                } catch (folderError) {
                  if (folderError.message.includes('404')) {
                    // Folder doesn't exist, create it
                    console.log(`Creating folder "${folderPath}"...`);
                    const createFolderOptions = {
                      method: 'PATCH',
                      hostname: 'graph.microsoft.com',
                      path: `/v1.0/sites/${process.env.SITE_ID}/drives/${driveId}/root/children`,
                      headers: {
                        'Authorization': `Bearer ${tokenData.access_token}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                      }
                    };
                    
                    await httpRequest(createFolderOptions, JSON.stringify({
                      name: folderPath,
                      folder: {},
                      '@microsoft.graph.conflictBehavior': 'rename'
                    }));
                    console.log(`Folder "${folderPath}" created successfully`);
                  } else {
                    throw folderError;
                  }
                }
              } catch (folderCreateError) {
                console.error(`Error managing folder "${folderPath}":`, folderCreateError.message);
                console.log('Will attempt to upload to the folder anyway...');
              }
              
              // Upload file to the specified folder
              const uploadOptions = {
                method: 'PUT',
                hostname: 'graph.microsoft.com',
                path: `/v1.0/sites/${process.env.SITE_ID}/drives/${driveId}/root:/${folderPath}/${fileName}:/content`,
                headers: {
                  'Authorization': `Bearer ${tokenData.access_token}`,
                  'Content-Type': 'text/csv',
                  'Content-Length': Buffer.byteLength(fileContent)
                }
              };
              
              const uploadData = await httpRequest(uploadOptions, fileContent);
              console.log('Successfully uploaded changelog to SharePoint');
              console.log(`File URL: ${uploadData.webUrl}`);
              
            } catch (error) {
              console.error('Error uploading to SharePoint:', error.message);
              // Don't fail the workflow if SharePoint upload fails
            }
        env:
          TENANT_ID: ${{ secrets.TENANT_ID }}
          CLIENT_ID: ${{ secrets.CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.CLIENT_SECRET }}
          SITE_ID: ${{ secrets.SITE_ID }}
          DRIVE_ID: ${{ secrets.DRIVE_ID || 'auto' }}
