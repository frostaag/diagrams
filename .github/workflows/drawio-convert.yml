name: Convert Draw.io Files

on:
  push:
    paths:
      - '**/*.drawio'
      - 'drawio_files/**'
  workflow_dispatch: # Enable manual triggering

# Add permissions needed for the workflow
permissions:
  contents: write

jobs:
  convert:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Check out the repository with history to detect changes
      - name: Check out the repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch all history to properly identify changed files
          
      # Step 1.1: Diagnostic information
      - name: Workflow diagnostic information
        run: |
          echo "============================================"
          echo "WORKFLOW DIAGNOSTIC INFORMATION"
          echo "============================================"
          echo "Repository: ${{ github.repository }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Actor: ${{ github.actor }}"
          echo "Workflow: ${{ github.workflow }}"
          echo "Event: ${{ github.event_name }}"
          echo "Commit: ${{ github.sha }}"
          echo "============================================"
          echo "LISTING DRAWIO FILES:"
          find drawio_files -name "*.drawio" -type f 2>/dev/null | sort || echo "No .drawio files found"
          echo "============================================"
          echo "GIT STATUS:"
          git status
          echo "============================================"
          echo "RECENTLY MODIFIED FILES:"
          git diff --name-only HEAD~5 HEAD 2>/dev/null || echo "Cannot get recent changes"
          echo "============================================"

      # Step 2: Install dependencies
      - name: Install Draw.io and dependencies
        run: |
          sudo apt-get update
          # Use libasound2t64 instead of libasound2 for Ubuntu Noble (24.04)
          sudo apt-get install -y wget unzip xvfb libasound2t64 libgbm1 libnspr4 libnss3 libxss1
          wget https://github.com/jgraph/drawio-desktop/releases/download/v26.2.2/drawio-amd64-26.2.2.deb
          sudo apt-get -f install -y
          sudo dpkg -i drawio-amd64-26.2.2.deb || sudo apt-get -f install -y
          
      # Step 1.2: Ensure directories exist
      - name: Create required directories
        run: |
          mkdir -p drawio_files svg_files html_files
          echo "Created necessary directories"

      # Step 2.5: Add .drawio extension to files without extension
      - name: Add .drawio extension to files without extension
        run: |
          # Check if drawio_files directory exists
          if [ -d "drawio_files" ]; then
            echo "Checking for files without extension in drawio_files directory..."
            
            # First, make sure we have the latest changes from remote
            echo "Fetching latest changes from remote repository..."
            git fetch "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"
            
            # Find files without extension in drawio_files directory
            # Use find command with null separator to handle filenames with spaces
            find drawio_files -type f -not -path "*/\.*" -print0 | while IFS= read -r -d $'\0' file; do
              # Check if filename contains a dot (which indicates an extension)
              filename=$(basename "$file")
              if [[ "$filename" != *.* ]]; then
                # Check if the file actually exists before trying to rename it
                if [ -f "$file" ]; then
                  echo "Adding .drawio extension to: $file"
                  
                  # Check if target file already exists (in case we've already renamed it)
                  if [ -f "${file}.drawio" ]; then
                    echo "Warning: ${file}.drawio already exists. Skipping rename."
                  else
                    # Check if file is a drawing
                    file_type=$(file -b "$file" | grep -i "xml" || echo "")
                    if [[ -n "$file_type" || $(head -c 100 "$file" | grep -q "mxfile") ]]; then
                      echo "File appears to be a draw.io diagram. Renaming..."
                      # Rename the file
                      mv "$file" "${file}.drawio"
                      
                      # Add and commit the renamed file
                      git add "${file}.drawio"
                      # Also remove the original file if git still tracks it
                      git rm --ignore-unmatch "$file" > /dev/null 2>&1
                      
                      git config --local user.name "github-actions[bot]"
                      git config --local user.email "github-actions[bot]@users.noreply.github.com"
                      git commit -m "Add .drawio extension to $filename"
                      
                      # Push changes immediately to avoid conflicts
                      echo "Pushing changes to remote repository..."
                      git push "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" HEAD:${GITHUB_REF#refs/heads/}
                    fi
                  fi
                else
                  echo "Warning: File $file no longer exists, skipping."
                fi
              fi
            done
          else
            echo "drawio_files directory not found, skipping extension check."
          fi          # Step 3: Create output directories
      - name: Create output folders
        run: |
          mkdir -p svg_files html_files
          
          # Initialize CSV changelog with headers if it doesn't exist - now with commit hash column
          if [ ! -f "html_files/CHANGELOG.csv" ]; then
            echo "Date,Time,User,Diagram,Action,File,Commit Message,Version,Commit Hash" > html_files/CHANGELOG.csv
          fi
          # No longer creating changelog in svg_files folder

      # Step 4: Convert .drawio files to SVG and wrap them in HTML
      - name: Convert Draw.io files
        run: |
          # Set up virtual display for headless operation
          Xvfb :99 -screen 0 1024x768x16 &
          export DISPLAY=:99
          sleep 1 # Give Xvfb time to start

          # Use a different approach - temporary script
          cat > /tmp/convert-drawio.sh << 'EOL'
          #!/bin/bash
          input_file=$1
          output_file=$2
          drawio -x -f svg -o "$output_file" "$input_file"
          EOL
          chmod +x /tmp/convert-drawio.sh

          # Create a file to track processed files to avoid duplicates
          > /tmp/processed_files.txt
          
          # Function to safely process filenames with spaces
          process_diagram_file() {
            local file_to_process="$1"
            echo "===== Processing: $file_to_process ====="
            
            # Check if this file has already been processed
            if grep -q "^$file_to_process\$" /tmp/processed_files.txt; then
              echo "File $file_to_process has already been processed in this run, skipping."
              return 3
            fi
            
            # Skip if file doesn't exist
            if [ ! -f "$file_to_process" ]; then
              echo "File $file_to_process no longer exists, skipping."
              return 1
            fi
            
            # Validation but allow for empty new diagrams
            echo "Validating Draw.io file format..."
            local file_size=$(stat -c%s "$file_to_process" 2>/dev/null || stat -f%z "$file_to_process")
            
            # Check if it contains the basic XML structure
            if ! grep -q "<mxfile" "$file_to_process"; then
              echo "ERROR: $file_to_process is not a valid Draw.io file (missing <mxfile> tag)."
              echo "File content preview:"
              head -c 200 "$file_to_process" | cat -A
              echo ""
              echo "Adding to failed files list..."
              echo "$file_to_process" >> /tmp/failed_files.txt
              echo "Base name: $(basename "$file_to_process" .drawio) - Invalid file format" >> /tmp/failed_files_details.txt
              return 4
            fi
            
            # Small file size warning, but we'll still attempt conversion for new empty diagrams
            if [ "$file_size" -lt 500 ]; then
              echo "NOTE: $file_to_process is very small ($file_size bytes). This is normal for a new empty diagram."
            fi
            
            # Check if this file was actually changed in the current commit
            local was_changed=false
            
            # Method 1: Check changed files list
            grep -q "^$file_to_process\$" /tmp/changed_files.txt && was_changed=true
            
            # Method 2: Direct git diff check (backup if grep fails due to special chars)
            if [ "$was_changed" = false ]; then
              git diff --name-only HEAD^ HEAD 2>/dev/null | grep -q "^$file_to_process\$" && was_changed=true
            fi
            
            # Special case for first commit or files specifically targeted
            if [ ! -s /tmp/changed_files.txt ] || grep -q "^$file_to_process\$" /tmp/files_with_spaces.txt; then
              was_changed=true
            fi
            
            if [ "$was_changed" = false ]; then
              echo "File $file_to_process was not changed in this commit, skipping."
              return 2
            fi
            
            echo "Confirmed $file_to_process was changed in this commit. Processing..."
            
            # Get the base filename without extension, preserving spaces
            local base_name=$(basename "$file_to_process" .drawio)
            echo "Base name: $base_name"
            
            # Create output directories if they don't exist
            mkdir -p "svg_files" "html_files"
            local output_svg="svg_files/${base_name}.svg"
            
            # Check if this is likely a new empty diagram
            local is_new_empty_diagram=false
            if [ "$file_size" -lt 500 ] && grep -q "<diagram" "$file_to_process" && ! grep -q "<mxCell" "$file_to_process"; then
              echo "This appears to be a new empty diagram. Will use special handling."
              is_new_empty_diagram=true
            fi
            
            # Convert to SVG with improved error handling
            echo "Converting to SVG..."
            # Create a backup first in case we need to investigate failure
            cp "$file_to_process" "${file_to_process}.backup" 2>/dev/null
            
            if [ "$is_new_empty_diagram" = true ]; then
              # For empty diagrams, create a simple SVG directly
              echo "Creating blank SVG for new empty diagram..."
              echo '<svg xmlns="http://www.w3.org/2000/svg" width="640" height="480" viewBox="0 0 640 480"><rect width="100%" height="100%" fill="white"/><text x="50%" y="50%" font-family="Arial" font-size="16" text-anchor="middle">New Empty Diagram</text><text x="50%" y="52%" font-family="Arial" font-size="12" text-anchor="middle" dy="20">Ready for editing</text></svg>' > "$output_svg"
              
              if [ -f "$output_svg" ]; then
                echo "Successfully created SVG for new empty diagram"
              else
                echo "ERROR: Failed to create SVG file for new empty diagram"
                return 1
              fi
            else
              # Standard conversion process for non-empty diagrams
              # Method 1: Try the main conversion script with timeout to avoid hanging
              timeout 60s xvfb-run -a /tmp/convert-drawio.sh "$file_to_process" "$output_svg" 2>/tmp/conversion_error.log
              
              # Check if conversion succeeded
              if [ ! -f "$output_svg" ]; then
                echo "First conversion method failed. Trying alternative method..."
                # Method 2: Try the direct drawio command
                timeout 60s xvfb-run -a drawio -x -f svg -o "$output_svg" "$file_to_process" 2>>/tmp/conversion_error.log
                
                # Method 3: If still failed, try with different display settings
                if [ ! -f "$output_svg" ]; then
                  echo "Second conversion method failed. Trying with modified display settings..."
                  export DISPLAY=:0
                  timeout 60s xvfb-run --server-args="-screen 0 1280x1024x24" drawio -x -f svg -o "$output_svg" "$file_to_process" 2>>/tmp/conversion_error.log
                
                  # If all methods failed, record detailed diagnostic info
                  if [ ! -f "$output_svg" ]; then
                    echo "ERROR: All conversion methods failed for $file_to_process"
                    echo "File info:"
                    ls -la "$file_to_process"
                    echo "Content preview:"
                    head -c 200 "$file_to_process" | hexdump -C
                    echo "Error log:"
                    cat /tmp/conversion_error.log
                    
                    # Record this failure for notification
                    echo "$file_to_process" >> /tmp/failed_files.txt
                    echo "Base name: $base_name" >> /tmp/failed_files_details.txt
                    
                    # Create a minimal valid SVG so the workflow can continue
                    echo '<svg xmlns="http://www.w3.org/2000/svg" width="640" height="480" viewBox="0 0 640 480"><rect width="100%" height="100%" fill="#ffffcc"/><text x="10" y="20" font-family="Arial" font-size="16">Error: Failed to convert diagram</text><text x="10" y="45" font-family="Arial" font-size="12">Please check the file and try again</text></svg>' > "$output_svg"
                    
                    echo "Created placeholder SVG to allow workflow to continue"
                    return 1
                  fi
                fi
              fi
            fi
            
            echo "Successfully converted to SVG!"
            
            # Create HTML wrapper
            echo "Creating HTML wrapper..."
            local output_html="html_files/${base_name}.html"
            echo '<!DOCTYPE html>' > "$output_html"
            echo '<html lang="en">' >> "$output_html"
            echo '<head>' >> "$output_html"
            echo '  <meta charset="UTF-8">' >> "$output_html"
            echo "  <title>${base_name}</title>" >> "$output_html"
            echo '  <style>' >> "$output_html"
            echo '    body { margin: 0; padding: 0; }' >> "$output_html"
            echo '    svg { max-width: 100%; height: auto; display: block; }' >> "$output_html"
            echo '  </style>' >> "$output_html"
            echo '</head>' >> "$output_html"
            echo '<body>' >> "$output_html"
            cat "$output_svg" >> "$output_html"
            echo '</body>' >> "$output_html"
            echo '</html>' >> "$output_html"
            
            # Get commit information
            local author=$(git log -1 --format="%aN" -- "$file_to_process" 2>/dev/null || echo "GitHub Actions")
            local commit_msg=$(git log -1 --format="%s" -- "$file_to_process" 2>/dev/null || echo "Processing file with spaces")
            local commit_msg_escaped=$(echo "$commit_msg" | sed 's/"/""/g')
            local formatted_date=$(date +"%d.%m.%Y")
            local formatted_time=$(date +"%H:%M:%S")
            local short_hash=$(git log -1 --pretty=format:"%h" -- "$file_to_process" 2>/dev/null || echo "manual")
            
            # Determine if this is new or modified
            local change_type="New"
            local git_history=$(git log --follow --pretty=format:"%h %s" -- "$file_to_process")
            local commit_count=$(echo "$git_history" | wc -l | tr -d ' ')
            
            if [ "$commit_count" -gt 1 ]; then
              change_type="Modified"
              local action_desc="Modified (Update)"
            else
              local action_desc="New"
            fi
            
            # Calculate version
            local version="1.0"
            if [ "$change_type" = "Modified" ]; then
              # Simple calculation: first update is 1.1, and so on
              local minor_version=$((commit_count - 1))
              version="1.${minor_version}"
            fi
            
            # Add changelog entry
            echo "$formatted_date,$formatted_time,\"$author\",\"${base_name}\",\"$action_desc\",\"${base_name}.drawio to ${base_name}.html\",\"$commit_msg_escaped\",\"$version\",\"$short_hash\"" >> html_files/CHANGELOG.csv
            echo "Added entry to changelog for $file_to_process ($action_desc) with version $version"
            
            # Mark this file as processed to avoid duplicates
            echo "$file_to_process" >> /tmp/processed_files.txt
            
            return 0
          }

          # Set debug output to help troubleshoot
          echo "Current directory: $(pwd)"
          echo "Listing drawio_files directory:"
          ls -la drawio_files || echo "drawio_files directory not found"
          
          # Get the list of changed .drawio files in the current commit
          # Use newline separated list to handle spaces in filenames
          git diff --name-only HEAD^ HEAD 2>/dev/null | grep -E "\.drawio$" > /tmp/changed_files.txt || echo "" > /tmp/changed_files.txt
          
          # If HEAD^ fails (first commit), try against empty tree
          if [ ! -s /tmp/changed_files.txt ]; then
            git diff-tree --name-only --no-commit-id --root -r HEAD | grep -E "\.drawio$" > /tmp/changed_files.txt || echo "" > /tmp/changed_files.txt
          fi
          
          echo "Files changed in this commit:"
          cat /tmp/changed_files.txt
          
          # Look for changed files with spaces
          echo "Checking for changed files with spaces in their names..."
          
          # Create a file to store changed files with spaces
          > /tmp/files_with_spaces.txt
          
          # Process each file in changed_files.txt to find those with spaces
          if [ -s /tmp/changed_files.txt ]; then
            while IFS= read -r file; do
              if [[ "$file" == *" "* ]]; then
                echo "Found changed file with spaces: $file"
                echo "$file" >> /tmp/files_with_spaces.txt
              fi
            done < /tmp/changed_files.txt
          fi
          
          # If no changed files were detected, we need to check if this commit is explicitly
          # for a file with spaces that might have been missed by git diff
          if [ ! -s /tmp/changed_files.txt ]; then
            # Get the commit message of the current commit
            CURRENT_COMMIT_MSG=$(git log -1 --format="%s")
            echo "Current commit message: $CURRENT_COMMIT_MSG"
            
            # If commit mentions a file with spaces, add it to our processing list
            if [[ "$CURRENT_COMMIT_MSG" == *"Diagram Test Git"* ]] || 
               [[ "$CURRENT_COMMIT_MSG" == *"Test Diag"* ]] ||
               [[ "$CURRENT_COMMIT_MSG" == *"Untitled Diagram"* ]]; then
              
              # Extract the likely filename from the commit message
              for part in $CURRENT_COMMIT_MSG; do
                if [[ -f "drawio_files/$part.drawio" ]]; then
                  echo "Found file mentioned in commit: drawio_files/$part.drawio"
                  echo "drawio_files/$part.drawio" >> /tmp/changed_files.txt
                  echo "drawio_files/$part.drawio" >> /tmp/files_with_spaces.txt
                fi
              done
            fi
          fi
          
          # Process any changed files with spaces first
          if [ -s /tmp/files_with_spaces.txt ]; then
            echo "========================================="
            echo "PROCESSING CHANGED FILES WITH SPACES IN THEIR NAMES"
            echo "========================================="
            while IFS= read -r space_file || [ -n "$space_file" ]; do
              echo "Processing changed file with spaces: $space_file"
              process_diagram_file "$space_file"
            done < /tmp/files_with_spaces.txt
          else
            echo "No changed files with spaces detected in this commit."
          fi

          # Now process remaining changed files (skipping those with spaces that were already processed)
          echo "========================================="
          echo "PROCESSING REMAINING CHANGED FILES"
          echo "========================================="
          
          # Create a temporary file for files without spaces
          > /tmp/files_without_spaces.txt
          
          # Filter out files that were already processed (those with spaces)
          while IFS= read -r changed_file || [ -n "$changed_file" ]; do
            # Skip files with spaces since they've already been processed
            if [[ "$changed_file" != *" "* ]]; then
              echo "$changed_file" >> /tmp/files_without_spaces.txt
            fi
          done < /tmp/changed_files.txt
          
          # Read line by line to process files without spaces
          while IFS= read -r changed_file || [ -n "$changed_file" ]; do
            # Use our dedicated function to process the file
            echo "Processing file without spaces: $changed_file"
            process_diagram_file "$changed_file"

            # NOTE: This part is no longer needed as the process_diagram_file function handles all this
            # HTML creation, changelog updates, etc. are now handled by the function
            
            # For backwards compatibility, we'll still set these variables
            # but the actual processing is done in the process_diagram_file function
            base=$(basename "$changed_file" .drawio)
            FILE_CHANGED=true
            AUTHOR=$(git log -1 --format="%aN" -- "$changed_file" 2>/dev/null || echo "${{ github.actor }}")
            COMMIT_MSG=$(git log -1 --format="%s" -- "$changed_file" 2>/dev/null || echo "No commit message")
            COMMIT_MSG=$(echo "$COMMIT_MSG" | sed 's/"/""/g')
            FORMATTED_DATE=$(date +"%d.%m.%Y")
            FORMATTED_TIME=$(date +"%H:%M:%S")
              
              # Check if this is a new diagram or a modification
              # First try with git history, fallback to file existence check
              if git ls-files --error-unmatch "svg_files/${base}.svg" &>/dev/null; then
                CHANGE_TYPE="Modified"
              else
                # Fallback to direct file check before our current conversion
                if [ -f "svg_files/${base}.svg.old" ]; then
                  CHANGE_TYPE="Modified"
                else
                  CHANGE_TYPE="New"
                fi
              fi
              
              # Make sure changelog directory exists
              mkdir -p svg_files html_files
              
              # Make debug output to understand what's happening
              echo "Creating changelog entries for: $base (${CHANGE_TYPE})"
              
              # Get enhanced version information using semantic versioning light (MAJOR.MINOR)
              # Use git history to determine if this is a major or minor change
              # Start with the commit message - if it contains keywords, categorize the change
              MAJOR_KEYWORDS="redesign|new version|complete|refactor|overhaul|major|added"
              MINOR_UPDATE_KEYWORDS="update|fix|adjust|tweak|enhance|improve|minor"
              
              # Default to standard minor change (increment minor version)
              IS_MAJOR_CHANGE=0
              CHANGE_DESCRIPTION="Change"
              
              # Check commit message for major change keywords (case insensitive)
              if echo "$COMMIT_MSG" | grep -iE "$MAJOR_KEYWORDS" > /dev/null; then
                IS_MAJOR_CHANGE=1
                CHANGE_DESCRIPTION="Major Change"
                echo "Detected major change based on commit message keywords"
              # Check for minor update keywords (case insensitive)
              elif echo "$COMMIT_MSG" | grep -iE "$MINOR_UPDATE_KEYWORDS" > /dev/null; then
                CHANGE_DESCRIPTION="Update"
                echo "Detected update based on commit message keywords"
              fi
              
              # Get file-specific history count for versioning
              echo "Looking for commit history of: $changed_file"
              # Store version history in a variable
              FILE_COMMIT_HISTORY=$(git log --follow --pretty=format:"%h %s" -- "$changed_file")
              echo "File commit history:"
              echo "$FILE_COMMIT_HISTORY"
              
              # Count file-specific commits only
              FILE_COMMIT_COUNT=$(echo "$FILE_COMMIT_HISTORY" | wc -l | tr -d ' ')
              echo "File has $FILE_COMMIT_COUNT commits in its history"
              
              # This section is now handled by the process_diagram_file function
              # But we'll maintain compatibility with the existing workflow by
              # setting variables that might be used elsewhere
              
              # Set default versions based on our improved logic
              MINOR_VERSION=$FILE_COMMIT_COUNT
              MAJOR_VERSION=1
              
              # For version calculation, we now use the simpler approach from our function
              if [ "$CHANGE_TYPE" = "New" ]; then
                VERSION="1.0"
              else
                # If this is the first update, it's 1.1, and so on
                MINOR_NUM=$((FILE_COMMIT_COUNT - 1))
                VERSION="1.${MINOR_NUM}"
              fi
              
              # Set action description
              if [ "$CHANGE_TYPE" = "New" ]; then
                ACTION_DESC="New"
              else
                ACTION_DESC="Modified (Update)"
              fi
              
              # These values are now informational only, as the actual changelog
              # entry was created by the process_diagram_file function
              COMMIT_HASH=$(git log -1 --pretty=format:"%H" -- "$changed_file" 2>/dev/null || echo "manual")
              SHORT_HASH=$(git log -1 --pretty=format:"%h" -- "$changed_file" 2>/dev/null || echo "manual")
              
              # The changelog entry has already been written by the process_diagram_file function
              echo "Processed $changed_file with version $VERSION (hash: $SHORT_HASH)"
            
          done < /tmp/files_without_spaces.txt

      # Step 5: Commit and push changes
      - name: Commit and push changes
        id: commit_changes
        run: |
          git config --local user.name "github-actions[bot]"
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          
          # Fetch latest changes before adding our changes
          echo "Fetching latest changes from remote repository..."
          git fetch origin
          
          # Add our changes
          git add svg_files html_files
          
          # Only commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
            echo "changes_made=false" >> $GITHUB_OUTPUT
          else
            git commit -m "Auto-converted draw.io files"
            
            # Pull the latest changes before pushing
            echo "Pulling latest changes from remote repository..."
            git pull --rebase origin ${GITHUB_REF#refs/heads/}
            
            # Use GitHub token for authentication and push
            echo "Pushing changes to remote repository..."
            git push "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" HEAD:${GITHUB_REF#refs/heads/}
            echo "changes_made=true" >> $GITHUB_OUTPUT
          fi
          
      # Step 5.1: Handle potential merge conflicts
      - name: Handle potential merge conflicts
        if: steps.commit_changes.outputs.changes_made == 'true'
        run: |
          # Check if there are merge conflicts
          if git status | grep -q "You have unmerged paths"; then
            echo "Detected merge conflicts. Attempting to resolve..."
            
            # Focus on CHANGELOG.csv which is the most common conflict
            if git status | grep -q "CHANGELOG.csv"; then
              echo "Resolving conflict in CHANGELOG.csv..."
              
              # Get our version (HEAD)
              git show :2:html_files/CHANGELOG.csv > /tmp/ours_changelog.csv
              
              # Get their version (from remote)
              git show :3:html_files/CHANGELOG.csv > /tmp/theirs_changelog.csv
              
              # Combine both files (skip header from the second file)
              head -n 1 /tmp/ours_changelog.csv > /tmp/merged_changelog.csv
              (tail -n +2 /tmp/ours_changelog.csv && tail -n +2 /tmp/theirs_changelog.csv) | sort | uniq >> /tmp/merged_changelog.csv
              
              # Replace the conflicted file with our merged version
              cp /tmp/merged_changelog.csv html_files/CHANGELOG.csv
              
              # Mark the conflict as resolved
              git add html_files/CHANGELOG.csv
              echo "CHANGELOG.csv conflict resolved automatically."
            else
              echo "Conflicts detected in files other than CHANGELOG.csv."
              echo "Please check the workflow logs and resolve conflicts manually."
              exit 1
            fi
            
            # Continue with the rebase
            if git rebase --continue; then
              echo "Rebase completed successfully after resolving conflicts."
            else
              echo "Could not continue rebase. Please check the repository."
              exit 1
            fi
          else
            echo "No merge conflicts detected."
          fi
          
      # Step 5.2: Push changes after handling conflicts
      - name: Push changes
        if: steps.commit_changes.outputs.changes_made == 'true'
        run: |
          # Try to push changes, with multiple retries for transient issues
          MAX_RETRIES=3
          RETRY_COUNT=0
          PUSH_SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$PUSH_SUCCESS" = false ]; do
            if git push origin main; then
              echo "Successfully pushed changes to remote repository."
              PUSH_SUCCESS=true
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "Push failed. Retrying in 5 seconds... (Attempt $RETRY_COUNT of $MAX_RETRIES)"
                sleep 5
                
                # Pull latest changes again before retrying
                echo "Pulling latest changes before retry..."
                git pull --rebase origin main || true
              else
                echo "Failed to push after $MAX_RETRIES attempts."
                echo "::warning::Failed to push changes automatically. Please check repository."
              fi
            fi
          done

      # Step 6: Upload changelog to SharePoint
      - name: Upload changelog to SharePoint
        if: steps.commit_changes.outputs.changes_made == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            try {
              const https = require('https');
              console.log('Preparing to upload changelog to SharePoint...');
              
              // Read and format the changelog file for SharePoint
              const changelogPath = path.join(process.env.GITHUB_WORKSPACE, 'html_files', 'CHANGELOG.csv');
              console.log(`Reading changelog from: ${changelogPath}`);
              const rawContent = fs.readFileSync(changelogPath, 'utf8');
              
              // Format the changelog with proper headers and content
              // First, parse the existing CSV
              const lines = rawContent.split('\n').filter(line => line.trim());
              const header = lines[0]; // Get header row
              const dataRows = lines.slice(1); // Get data rows
              
              // Create a properly formatted CSV with all the needed columns in the requested order
              // Date, Time, Diagram, Action, File, Commit Message, Version, Commit Hash
              let fileContent = 'Date,Time,Diagram,Action,File,Commit Message,Version,Commit Hash\n';
              
              // Add the data rows with today's upload date
              const today = new Date().toLocaleDateString('en-GB', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric'
              }); // Format as DD.MM.YYYY
              
              // Process each row to handle the changed column ordering
              dataRows.forEach(row => {
                if (row.trim()) {
                  // Using a more robust CSV parsing approach
                  try {
                    // First, parse the CSV properly using a regex that handles quoted fields with commas
                    const parseCSV = (text) => {
                      const result = [];
                      const regex = /("[^"]*"|[^,"\r\n]+)(?=,|\r\n|$)|^(?=,|$)|,(?=,|$)/g;
                      let m;
                      
                      while ((m = regex.exec(text)) !== null) {
                        // Remove quotes if the field is quoted
                        let field = m[1] || '';
                        if (field.startsWith('"') && field.endsWith('"')) {
                          field = field.substring(1, field.length - 1);
                        }
                        result.push(field);
                      }
                      
                      return result;
                    };
                    
                    const extractedCols = parseCSV(row);
                    
                    // Ensure we have enough columns and handle missing values
                    while (extractedCols.length < 9) {
                      extractedCols.push('');
                    }
                    
                    // For reference, original columns are:
                    // [0]Date, [1]Time, [2]User, [3]Diagram, [4]Action, [5]File, [6]Commit Message, [7]Version, [8]Commit Hash
                    
                    // Keeping same format, just removing the SharePoint Upload Date:
                    // [0]Date, [1]Time, [2]Diagram, [3]Action, [4]File, [5]Commit Message, [6]Version, [7]Commit Hash
                    
                    // Create a properly formatted CSV row with quotes around each field
                    const formattedRow = [
                      extractedCols[0],                      // Date
                      extractedCols[1],                      // Time
                      `"${(extractedCols[3] || '').replace(/"/g, '""')}"`,  // Diagram
                      `"${(extractedCols[4] || '').replace(/"/g, '""')}"`,  // Action
                      `"${(extractedCols[5] || '').replace(/"/g, '""')}"`,  // File
                      `"${(extractedCols[6] || '').replace(/"/g, '""')}"`,  // Commit Message
                      extractedCols[7] || '',                // Version
                      extractedCols[8] || ''                 // Commit Hash
                    ].join(',');
                    
                    fileContent += formattedRow + '\n';
                  } catch (error) {
                    console.error(`Error processing CSV row: ${row}`, error);
                    // Skip this row if there's an error
                  }
                }
              });
              
              console.log(`Formatted changelog with ${dataRows.length} entries`);
              
              // Function to make HTTP requests with promises
              const httpRequest = (options, postData) => {
                return new Promise((resolve, reject) => {
                  const req = https.request(options, (res) => {
                    let data = '';
                    res.on('data', (chunk) => { data += chunk; });
                    res.on('end', () => {
                      if (res.statusCode >= 200 && res.statusCode < 300) {
                        try {
                          resolve(data.length > 0 ? JSON.parse(data) : {});
                        } catch (e) {
                          resolve(data); // Not JSON, return as string
                        }
                      } else {
                        reject(new Error(`HTTP Error: ${res.statusCode} ${data}`));
                      }
                    });
                  });
                  
                  req.on('error', reject);
                  
                  if (postData) {
                    req.write(postData);
                  }
                  req.end();
                });
              };
              
              // Step 1: Get access token with proper SharePoint permissions
              console.log('Getting access token...');
              const tokenBody = new URLSearchParams({
                client_id: process.env.CLIENT_ID,
                scope: 'https://graph.microsoft.com/.default',
                client_secret: process.env.CLIENT_SECRET,
                grant_type: 'client_credentials'
              }).toString();
              
              const tokenOptions = {
                method: 'POST',
                hostname: 'login.microsoftonline.com',
                path: `/${process.env.TENANT_ID}/oauth2/v2.0/token`,
                headers: {
                  'Content-Type': 'application/x-www-form-urlencoded',
                  'Content-Length': Buffer.byteLength(tokenBody)
                }
              };
              
              // Get token
              const tokenData = await httpRequest(tokenOptions, tokenBody);
              console.log('Access token obtained');
              
              // Step 2: Get drives if needed
              // Force drive ID detection regardless of configured value due to previous errors
              console.log('Attempting to detect SharePoint drives automatically...');
              
              // Verify the site ID from secrets
              try {
                console.log(`Verifying site ID from secret: ${process.env.SITE_ID}`);
                
                const siteOptions = {
                  method: 'GET',
                  hostname: 'graph.microsoft.com',
                  path: `/v1.0/sites/${process.env.SITE_ID}`,
                  headers: {
                    'Authorization': `Bearer ${tokenData.access_token}`,
                    'Accept': 'application/json'
                  }
                };
                
                const siteData = await httpRequest(siteOptions);
                console.log(`Site found: ${siteData.displayName || siteData.name}`);
              } catch (siteError) {
                console.error('Error verifying site:', siteError.message);
                console.log('Trying alternative site path format...');
                // If the site ID doesn't work, try a different format
                const originalSiteId = process.env.SITE_ID;
                try {
                  // Try sites/SiteName format
                  if (!originalSiteId.startsWith('sites/')) {
                    process.env.SITE_ID = `sites/${originalSiteId.split('/').pop()}`;
                  } else {
                    // Or try domain,sites,SiteName format
                    process.env.SITE_ID = `frostaag.sharepoint.com,${originalSiteId.replace('/', ',')}`;
                  }
                  console.log(`Using alternative site ID format: ${process.env.SITE_ID}`);
                } catch (formatError) {
                  console.error('Error reformatting site ID:', formatError);
                  // Keep the original if parsing fails
                }
              }
              
              // Now get the list of drives
              const drivesOptions = {
                method: 'GET',
                hostname: 'graph.microsoft.com',
                path: `/v1.0/sites/${process.env.SITE_ID}/drives`,
                headers: {
                  'Authorization': `Bearer ${tokenData.access_token}`,
                  'Accept': 'application/json'
                }
              };
              
              console.log(`Requesting drives list from: ${drivesOptions.path}`);
              const drivesData = await httpRequest(drivesOptions);
              
              if (!drivesData.value || drivesData.value.length === 0) {
                throw new Error(`No drives found for site: ${process.env.SITE_ID}`);
              }
              
              console.log('Available drives:');
              drivesData.value.forEach(d => console.log(`- ${d.name}: ${d.id}`));
              
              // Try to find the Documents drive - prioritize "Shared Documents" 
              console.log('Looking for document library named "Shared Documents"');
              const documentsDrive = drivesData.value.find(d => 
                d.name === 'Shared Documents' || 
                d.name === 'Documents' || 
                d.name.includes('Document')
              );
              
              let driveId;
              if (documentsDrive) {
                driveId = documentsDrive.id;
                console.log(`Selected document library: ${documentsDrive.name} (${driveId})`);
              } else {
                // Fall back to first drive
                driveId = drivesData.value[0].id;
                console.log(`No document library found, using first available drive: ${drivesData.value[0].name} (${driveId})`);
              }
              
              // Step 3: Upload the file - use consistent filename instead of date-stamped
              const fileName = 'Diagrams_Changelog.csv';  // Fixed filename that will be overwritten each time
              const folderPath = 'Diagrams';  // Target folder in SharePoint DatasphereFileStorage site
              console.log(`Uploading changelog as ${fileName} to folder "${folderPath}" in drive ${driveId}...`);
              
              // Create the folder if it doesn't exist
              try {
                const folderCheckOptions = {
                  method: 'GET',
                  hostname: 'graph.microsoft.com',
                  path: `/v1.0/sites/${process.env.SITE_ID}/drives/${driveId}/root:/${folderPath}`,
                  headers: {
                    'Authorization': `Bearer ${tokenData.access_token}`,
                    'Accept': 'application/json'
                  }
                };
                
                // Check if folder exists
                try {
                  await httpRequest(folderCheckOptions);
                  console.log(`Folder "${folderPath}" already exists`);
                } catch (folderError) {
                  if (folderError.message.includes('404')) {
                    // Folder doesn't exist, create it
                    console.log(`Creating folder "${folderPath}"...`);
                    const createFolderOptions = {
                      method: 'PATCH',
                      hostname: 'graph.microsoft.com',
                      path: `/v1.0/sites/${process.env.SITE_ID}/drives/${driveId}/root/children`,
                      headers: {
                        'Authorization': `Bearer ${tokenData.access_token}`,
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                      }
                    };
                    
                    await httpRequest(createFolderOptions, JSON.stringify({
                      name: folderPath,
                      folder: {},
                      '@microsoft.graph.conflictBehavior': 'rename'
                    }));
                    console.log(`Folder "${folderPath}" created successfully`);
                  } else {
                    throw folderError;
                  }
                }
              } catch (folderCreateError) {
                console.error(`Error managing folder "${folderPath}":`, folderCreateError.message);
                console.log('Will attempt to upload to the folder anyway...');
              }
              
              // Upload file to the specified folder
              const uploadOptions = {
                method: 'PUT',
                hostname: 'graph.microsoft.com',
                path: `/v1.0/sites/${process.env.SITE_ID}/drives/${driveId}/root:/${folderPath}/${fileName}:/content`,
                headers: {
                  'Authorization': `Bearer ${tokenData.access_token}`,
                  'Content-Type': 'text/csv',
                  'Content-Length': Buffer.byteLength(fileContent)
                }
              };
              
              const uploadData = await httpRequest(uploadOptions, fileContent);
              console.log('Successfully uploaded changelog to SharePoint');
              console.log(`File URL: ${uploadData.webUrl}`);
              
            } catch (error) {
              console.error('Error uploading to SharePoint:', error.message);
              // Don't fail the workflow if SharePoint upload fails
            }
        env:
          TENANT_ID: ${{ secrets.TENANT_ID }}
          CLIENT_ID: ${{ secrets.CLIENT_ID }}
          CLIENT_SECRET: ${{ secrets.CLIENT_SECRET }}
          SITE_ID: ${{ secrets.SITE_ID }}
          DRIVE_ID: ${{ secrets.DRIVE_ID || 'auto' }}
  
  # Notifications for both success and failure
  teams-notification:
    needs: convert
    runs-on: ubuntu-latest
    if: ${{ always() }}  # Run this job whether the main job succeeds or fails
    
    steps:
      # This step runs only on success
      - name: Send Teams success notification
        if: ${{ needs.convert.result == 'success' }}
        run: |
          # Create JSON payload for Teams webhook
          PAYLOAD=$(cat << EOF
          {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "themeColor": "00FF00",
            "summary": "Draw.io Conversion Workflow Succeeded",
            "sections": [
              {
                "activityTitle": "✅ Draw.io Conversion Workflow Completed",
                "activitySubtitle": "Diagrams were successfully processed",
                "facts": [
                  {
                    "name": "Repository",
                    "value": "${{ github.repository }}"
                  },
                  {
                    "name": "Workflow",
                    "value": "${{ github.workflow }}"
                  },
                  {
                    "name": "Commit",
                    "value": "${{ github.sha }}"
                  },
                  {
                    "name": "Triggered by",
                    "value": "${{ github.actor }}"
                  }
                ],
                "markdown": true
              }
            ],
            "potentialAction": [
              {
                "@type": "OpenUri",
                "name": "View Workflow Run",
                "targets": [
                  {
                    "os": "default",
                    "uri": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                ]
              }
            ]
          }
          EOF
          )
          
          # Send the payload to Teams webhook
          curl -H "Content-Type: application/json" -d "$PAYLOAD" "${{ secrets.TEAMS_WEBHOOK }}"

      # This step runs only on failure
      - name: Send Teams failure notification
        if: ${{ needs.convert.result == 'failure' }}
        run: |
          # Create JSON payload for Teams webhook
          PAYLOAD=$(cat << EOF
          {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "themeColor": "FF0000",
            "summary": "Draw.io Conversion Workflow Failed",
            "sections": [
              {
                "activityTitle": "❌ Draw.io Conversion Workflow Failed",
                "activitySubtitle": "GitHub Actions workflow run failed",
                "facts": [
                  {
                    "name": "Repository",
                    "value": "${{ github.repository }}"
                  },
                  {
                    "name": "Workflow",
                    "value": "${{ github.workflow }}"
                  },
                  {
                    "name": "Commit",
                    "value": "${{ github.sha }}"
                  },
                  {
                    "name": "Triggered by",
                    "value": "$TRIGGERER_NAME"
                  },
                  {
                    "name": "Run ID",
                    "value": "${{ github.run_id }}"
                  }
                ],
                "markdown": true
              }
            ],
            "potentialAction": [
              {
                "@type": "OpenUri",
                "name": "View Workflow Run",
                "targets": [
                  {
                    "os": "default",
                    "uri": "https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                ]
              }
            ]
          }
          EOF
          )
          
          # Send the payload to Teams webhook
          curl -H "Content-Type: application/json" -d "$PAYLOAD" "${{ secrets.TEAMS_WEBHOOK }}"
      # Step 2: Check for file changes
      - name: Check for changed Draw.io files
        id: check_files
        run: |
          echo "Checking for changed .drawio files..."
          
          # Initialize output
          CHANGES_DETECTED=false
          
          # Method 1: Check for changes between HEAD and HEAD^
          echo "Trying method 1: git diff HEAD^ HEAD"
          if git diff --name-only HEAD^ HEAD 2>/dev/null | grep -q "\.drawio$"; then
            CHANGES_DETECTED=true
            echo "Changes detected using method 1"
          fi
          
          # If method 1 failed, try method 2 (useful for initial commits)
          if [ "$CHANGES_DETECTED" = false ]; then
            echo "Trying method 2: git diff-tree (for initial commits)"
            if git diff-tree --no-commit-id --name-only -r HEAD 2>/dev/null | grep -q "\.drawio$"; then
              CHANGES_DETECTED=true
              echo "Changes detected using method 2"
            fi
          fi
          
          # If still no changes detected, try method 3 (list all .drawio files on a new repo)
          if [ "$CHANGES_DETECTED" = false ]; then
            echo "Trying method 3: check for existence of any .drawio files"
            if find . -name "*.drawio" -type f 2>/dev/null | grep -q "\.drawio$"; then
              CHANGES_DETECTED=true
              echo "Changes detected using method 3 (found .drawio files)"
            fi
          fi
          
          # Set the output
          if [ "$CHANGES_DETECTED" = true ]; then
            echo "files_changed=true" >> $GITHUB_OUTPUT
            echo ".drawio files were changed or found in this commit"
          else
            echo "files_changed=false" >> $GITHUB_OUTPUT
            echo "No .drawio files were changed in this commit"
          fi
      # Step 3: Analyze and process new diagrams for auto ID assignment
      - name: Auto-assign IDs to new diagrams
        id: auto_id
        if: ${{ steps.check_files.outputs.files_changed == 'true' }}
        run: |
          # Initialize outputs
          echo "id_assigned=false" >> $GITHUB_OUTPUT
          echo "renamed_files=" >> $GITHUB_OUTPUT
          
          # Create a list to store renamed files
          RENAMED_FILES=()
          ID_ASSIGNED=false
          
          # Get list of changed Draw.io files in this commit using multiple methods
          echo "Getting list of .drawio files to process..."
          
          # Method 1: Standard diff (most commits)
          CHANGED_FILES=$(git diff --name-only HEAD^ HEAD 2>/dev/null | grep "\.drawio$" || echo "")
          
          # Method 2: For initial commits
          if [ -z "$CHANGED_FILES" ]; then
            CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r HEAD 2>/dev/null | grep "\.drawio$" || echo "")
            echo "Using diff-tree method for initial commit, found: $CHANGED_FILES"
          fi
          
          # Method 3: For new repositories, check all .drawio files
          if [ -z "$CHANGED_FILES" ]; then
            CHANGED_FILES=$(find . -name "*.drawio" -type f | sed 's|^\./||' || echo "")
            echo "Using find method for new repository, found: $CHANGED_FILES"
          fi
          
          echo "Draw.io files to process: $CHANGED_FILES"
          
          # Debug output
          echo "Current directory: $(pwd)"
          echo "Listing all .drawio files for reference:"
          find . -name "*.drawio" -type f | sort
          
          # Process each changed file to see if it needs ID assignment
          for file in $CHANGED_FILES; do
            # Make sure the file exists (useful if we're parsing git output)
            if [ ! -f "$file" ]; then
              echo "File not found: $file, skipping..."
              continue
            fi
            
            # Extract just the filename without path and extension
            base_name=$(basename "$file" .drawio)
            
            # Debug information
            echo "Processing file: $file with base_name: $base_name"
            
            # Test each pattern (for debugging)
            if [[ "$base_name" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.\ .* ]]; then
              echo "  Pattern 1 (X.Y.Z. Name) matches"
            fi
            if [[ "$base_name" =~ ^[0-9]+\.[0-9]+\.\ .* ]]; then
              echo "  Pattern 2 (X.Y. Name) matches"
            fi
            if [[ "$base_name" =~ ^[0-9]+\.[0-9]+\ .* ]]; then
              echo "  Pattern 3 (X.Y Name) matches"
            fi
            
            # Check file patterns in order:
            # 1. Already has a full ID with dot (e.g., "3.1.4. SAP Overview")
            # 2. Already has a full ID without dot (e.g., "3.1.4 SAP Overview")
            # 3. Has a partial ID with dot (e.g., "3.1. SAP Overview")
            # 4. Has a partial ID without dot (e.g., "3.1 SAP Overview") - this needs ID assignment
            
            if [[ "$base_name" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.\ .* ]]; then
              echo "File already has a complete ID: $file (X.Y.Z. Name format)"
              
            elif [[ "$base_name" =~ ^[0-9]+\.[0-9]+\.[0-9]+\ .* ]]; then
              echo "File already has a complete ID: $file (X.Y.Z Name format)"
              
            elif [[ "$base_name" =~ ^[0-9]+\.[0-9]+\.\ .* ]]; then
              echo "File already has a partial ID with dot: $file (X.Y. Name format)"
              
            elif [[ "$base_name" =~ ^([0-9]+)\.([0-9]+)\ (.*) ]]; then
              # Extract category and detail level, then combine for prefix
              CATEGORY="${BASH_REMATCH[1]}"
              DETAIL="${BASH_REMATCH[2]}"
              PREFIX="${CATEGORY}.${DETAIL}"
              NAME="${BASH_REMATCH[3]}"
              
              echo "Matched pattern for file needing ID: $file"
              echo "  Category: $CATEGORY"
              echo "  Detail: $DETAIL"
              echo "  Prefix: $PREFIX"
              echo "  Name: $NAME"
              
              echo "Found file with partial ID: $file"
              echo "Prefix: $PREFIX, Name: $NAME"
              
              # Find highest existing ID for this prefix
              HIGHEST_ID=0
              echo "Looking for existing diagrams with prefix $PREFIX..."
              
              # Look for files matching the pattern X.Y.Z. format
              for existing in drawio_files/*.drawio; do
                existing_base=$(basename "$existing" .drawio)
                echo "  Checking: $existing_base"
                
                # Match both X.Y.Z. format and X.Y.Z format (with or without trailing dot)
                if [[ "$existing_base" =~ ^${PREFIX}\.([0-9]+)\.\ .* ]] || [[ "$existing_base" =~ ^${PREFIX}\.([0-9]+)\ .* ]]; then
                  CURRENT_ID="${BASH_REMATCH[1]}"
                  echo "    Found ID: $CURRENT_ID"
                  
                  if [[ "$CURRENT_ID" -gt "$HIGHEST_ID" ]]; then
                    HIGHEST_ID="$CURRENT_ID"
                    echo "    New highest ID: $HIGHEST_ID"
                  fi
                fi
              done
              
              echo "Highest existing ID found: $HIGHEST_ID"
              
              # Calculate next ID
              NEXT_ID=$((HIGHEST_ID + 1))
              
              # Generate new filename
              NEW_NAME="${PREFIX}.${NEXT_ID}. ${NAME}"
              NEW_PATH="drawio_files/${NEW_NAME}.drawio"
              
              echo "Renaming: $file -> $NEW_PATH (next ID: $NEXT_ID)"
              
              # First make sure the target directory exists
              mkdir -p $(dirname "$NEW_PATH")
              
              # Use git mv for the rename, but handle errors
              if git mv -f "$file" "$NEW_PATH" 2>/dev/null; then
                echo "Successfully renamed file with git mv"
              else
                echo "git mv failed, trying regular mv and git add/rm"
                mv -f "$file" "$NEW_PATH"
                git rm -f "$file" 2>/dev/null || true
                git add "$NEW_PATH"
              fi
              
              RENAMED_FILES+=("$NEW_PATH")
              ID_ASSIGNED=true
              
              echo "Successfully renamed diagram with next available ID: $NEXT_ID"
            fi
          done
          
          # Set outputs
          if [ "$ID_ASSIGNED" = true ]; then
            echo "id_assigned=true" >> $GITHUB_OUTPUT
            echo "renamed_files=${RENAMED_FILES[*]}" >> $GITHUB_OUTPUT
          fi
      
      # Step 3.1: Commit the renamed diagrams if any
      - name: Commit renamed diagrams
        id: commit_renamed
        if: ${{ steps.auto_id.outputs.id_assigned == 'true' }}
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Create timestamp for unique commit message
          TIMESTAMP=$(date +"%Y%m%d%H%M%S")
          
          # Make sure all renamed files are staged
          if [[ -n "${{ steps.auto_id.outputs.renamed_files }}" ]]; then
            echo "Committing renamed files: ${{ steps.auto_id.outputs.renamed_files }}"
            # Add specific files that were renamed
            for file in ${{ steps.auto_id.outputs.renamed_files }}; do
              git add "$file"
            done
          else
            echo "No specific files to add, adding all changes"
            git add .
          fi
          
          # Check if there are really changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit after renaming."
            echo "commit_done=false" >> $GITHUB_OUTPUT
          else
            git commit -m "Auto-assigned IDs to new diagrams [${TIMESTAMP}]"
            echo "commit_done=true" >> $GITHUB_OUTPUT
            
            echo "Pushing changes to remote repository..."
            git push origin HEAD:${GITHUB_REF#refs/heads/}
          fi
      # Step 4: Detect and regenerate missing HTML/SVG files
      - name: Check for missing generated files
        id: check_missing
        run: |
          # Initialize variables to track if missing files were found
          MISSING_HTML_FILES=false
          MISSING_SVG_FILES=false
          MISSING_FILES_LIST=""
          
          # Create these directories if they don't exist
          mkdir -p svg_files html_files
          
          echo "Checking for Draw.io files without corresponding HTML or SVG files..."
          for drawio_file in drawio_files/*.drawio; do
            # Skip if no files match
            [ -e "$drawio_file" ] || continue
            
            # Get the base name without extension
            base_name=$(basename "$drawio_file" .drawio)
            
            # Check if HTML file exists
            html_file="html_files/${base_name}.html"
            if [ ! -f "$html_file" ]; then
              echo "Missing HTML file for: $drawio_file"
              MISSING_HTML_FILES=true
              MISSING_FILES_LIST="${MISSING_FILES_LIST}${base_name} (HTML), "
            fi
            
            # Check if SVG file exists
            svg_file="svg_files/${base_name}.svg"
            if [ ! -f "$svg_file" ]; then
              echo "Missing SVG file for: $drawio_file"
              MISSING_SVG_FILES=true
              MISSING_FILES_LIST="${MISSING_FILES_LIST}${base_name} (SVG), "
            fi
            
            # If either file is missing, add the drawio file to the queue for processing
            if [ ! -f "$html_file" ] || [ ! -f "$svg_file" ]; then
              echo "$drawio_file" >> /tmp/files_to_process.txt
            fi
          done
          
          # Trim trailing comma and space
          MISSING_FILES_LIST="${MISSING_FILES_LIST%, }"
          
          # Set outputs for conditional steps
          if [ "$MISSING_HTML_FILES" = true ] || [ "$MISSING_SVG_FILES" = true ]; then
            echo "missing_files=true" >> $GITHUB_OUTPUT
            echo "missing_files_list=$MISSING_FILES_LIST" >> $GITHUB_OUTPUT
          else
            echo "missing_files=false" >> $GITHUB_OUTPUT
          fi
      
      # Step 4.1: Process missing files if any
      - name: Regenerate missing files
        if: ${{ steps.check_missing.outputs.missing_files == 'true' }}
        run: |
          echo "Regenerating missing HTML/SVG files..."
          
          # Create a function for processing the diagram files
          process_missing_diagram() {
            local file_to_process="$1"
            echo "===== Processing missing files for: $file_to_process ====="
            
            # Get the base filename without extension, preserving spaces
            local base_name=$(basename "$file_to_process" .drawio)
            echo "Base name: $base_name"
            
            # Output files
            local output_svg="svg_files/${base_name}.svg"
            local output_html="html_files/${base_name}.html"
            
            # Only regenerate SVG if it's missing
            if [ ! -f "$output_svg" ]; then
              echo "Regenerating SVG file..."
              # Convert to SVG using the standard approach
              xvfb-run -a drawio -x -f svg -o "$output_svg" "$file_to_process"
              
              # Check if conversion succeeded
              if [ ! -f "$output_svg" ]; then
                echo "Warning: SVG generation failed for $file_to_process"
                # Create a placeholder SVG
                echo '<svg xmlns="http://www.w3.org/2000/svg" width="640" height="480" viewBox="0 0 640 480"><rect width="100%" height="100%" fill="#fff1f1"/><text x="50%" y="50%" font-family="Arial" font-size="16" text-anchor="middle">SVG Regeneration Failed</text><text x="50%" y="50%" font-family="Arial" font-size="12" text-anchor="middle" dy="20">Please update this diagram file</text></svg>' > "$output_svg"
              fi
            fi
            
            # Only regenerate HTML if it's missing
            if [ ! -f "$output_html" ]; then
              echo "Regenerating HTML file..."
              echo '<!DOCTYPE html>' > "$output_html"
              echo '<html lang="en">' >> "$output_html"
              echo '<head>' >> "$output_html"
              echo '  <meta charset="UTF-8">' >> "$output_html"
              echo "  <title>${base_name}</title>" >> "$output_html"
              echo '  <style>' >> "$output_html"
              echo '    body { margin: 0; padding: 0; }' >> "$output_html"
              echo '    svg { max-width: 100%; height: auto; display: block; }' >> "$output_html"
              echo '  </style>' >> "$output_html"
              echo '</head>' >> "$output_html"
              echo '<body>' >> "$output_html"
              
              # If SVG exists, include it
              if [ -f "$output_svg" ]; then
                cat "$output_svg" >> "$output_html"
              else
                echo "<p>Error: SVG file not found for ${base_name}</p>" >> "$output_html"
              fi
              
              echo '</body>' >> "$output_html"
              echo '</html>' >> "$output_html"
            fi
            
            echo "Completed regeneration of missing files for $file_to_process"
          }
          
          # Process each file that has missing HTML or SVG
          if [ -f "/tmp/files_to_process.txt" ]; then
            while IFS= read -r file || [ -n "$file" ]; do
              process_missing_diagram "$file"
            done < "/tmp/files_to_process.txt"
          fi
          
          echo "Finished regenerating all missing files"
